"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main",{

/***/ "../node_modules/next/dist/client/index.js":
/*!*************************************************!*\
  !*** ../node_modules/next/dist/client/index.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/* global location */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"../node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    version: function() {\n        return version;\n    },\n    router: function() {\n        return router;\n    },\n    emitter: function() {\n        return emitter;\n    },\n    initialize: function() {\n        return initialize;\n    },\n    hydrate: function() {\n        return hydrate;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"../node_modules/@swc/helpers/esm/_interop_require_default.js\");\n__webpack_require__(/*! ../build/polyfills/polyfill-module */ \"../node_modules/next/dist/build/polyfills/polyfill-module.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"../node_modules/react/index.js\"));\nconst _client = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom/client */ \"../node_modules/react-dom/client.js\"));\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ../shared/lib/head-manager-context.shared-runtime */ \"../node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _mitt = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../shared/lib/mitt */ \"../node_modules/next/dist/shared/lib/mitt.js\"));\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"../node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _handlesmoothscroll = __webpack_require__(/*! ../shared/lib/router/utils/handle-smooth-scroll */ \"../node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\");\nconst _isdynamic = __webpack_require__(/*! ../shared/lib/router/utils/is-dynamic */ \"../node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nconst _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"../node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nconst _runtimeconfigexternal = __webpack_require__(/*! ../shared/lib/runtime-config.external */ \"../node_modules/next/dist/shared/lib/runtime-config.external.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"../node_modules/next/dist/shared/lib/utils.js\");\nconst _portal = __webpack_require__(/*! ./portal */ \"../node_modules/next/dist/client/portal/index.js\");\nconst _headmanager = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./head-manager */ \"../node_modules/next/dist/client/head-manager.js\"));\nconst _pageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./page-loader */ \"../node_modules/next/dist/client/page-loader.js\"));\nconst _performancerelayer = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./performance-relayer */ \"../node_modules/next/dist/client/performance-relayer.js\"));\nconst _routeannouncer = __webpack_require__(/*! ./route-announcer */ \"../node_modules/next/dist/client/route-announcer.js\");\nconst _router = __webpack_require__(/*! ./router */ \"../node_modules/next/dist/client/router.js\");\nconst _iserror = __webpack_require__(/*! ../lib/is-error */ \"../node_modules/next/dist/lib/is-error.js\");\nconst _imageconfigcontextsharedruntime = __webpack_require__(/*! ../shared/lib/image-config-context.shared-runtime */ \"../node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\");\nconst _removebasepath = __webpack_require__(/*! ./remove-base-path */ \"../node_modules/next/dist/client/remove-base-path.js\");\nconst _hasbasepath = __webpack_require__(/*! ./has-base-path */ \"../node_modules/next/dist/client/has-base-path.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../shared/lib/app-router-context.shared-runtime */ \"../node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _adapters = __webpack_require__(/*! ../shared/lib/router/adapters */ \"../node_modules/next/dist/shared/lib/router/adapters.js\");\nconst _hooksclientcontextsharedruntime = __webpack_require__(/*! ../shared/lib/hooks-client-context.shared-runtime */ \"../node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js\");\nconst _onrecoverableerror = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./on-recoverable-error */ \"../node_modules/next/dist/client/on-recoverable-error.js\"));\nconst _tracer = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./tracing/tracer */ \"../node_modules/next/dist/client/tracing/tracer.js\"));\nconst _reporttosocket = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./tracing/report-to-socket */ \"../node_modules/next/dist/client/tracing/report-to-socket.js\"));\nconst version = \"13.5.2\";\nlet router;\nconst emitter = (0, _mitt.default)();\nconst looseToArray = (input)=>[].slice.call(input);\nlet initialData;\nlet defaultLocale = undefined;\nlet asPath;\nlet pageLoader;\nlet appElement;\nlet headManager;\nlet initialMatchesMiddleware = false;\nlet lastAppProps;\nlet lastRenderReject;\nlet devClient;\nlet CachedApp, onPerfEntry;\nlet CachedComponent;\nclass Container extends _react.default.Component {\n    componentDidCatch(componentErr, info) {\n        this.props.fn(componentErr, info);\n    }\n    componentDidMount() {\n        this.scrollToHash();\n        // We need to replace the router state if:\n        // - the page was (auto) exported and has a query string or search (hash)\n        // - it was auto exported and is a dynamic route (to provide params)\n        // - if it is a client-side skeleton (fallback render)\n        // - if middleware matches the current page (may have rewrite params)\n        // - if rewrites in next.config.js match (may have rewrite params)\n        if (router.isSsr && (initialData.isFallback || initialData.nextExport && ((0, _isdynamic.isDynamicRoute)(router.pathname) || location.search || false || initialMatchesMiddleware) || initialData.props && initialData.props.__N_SSG && (location.search || false || initialMatchesMiddleware))) {\n            // update query on mount for exported pages\n            router.replace(router.pathname + \"?\" + String((0, _querystring.assign)((0, _querystring.urlQueryToSearchParams)(router.query), new URLSearchParams(location.search))), asPath, {\n                // @ts-ignore\n                // WARNING: `_h` is an internal option for handing Next.js\n                // client-side hydration. Your app should _never_ use this property.\n                // It may change at any time without notice.\n                _h: 1,\n                // Fallback pages must trigger the data fetch, so the transition is\n                // not shallow.\n                // Other pages (strictly updating query) happens shallowly, as data\n                // requirements would already be present.\n                shallow: !initialData.isFallback && !initialMatchesMiddleware\n            }).catch((err)=>{\n                if (!err.cancelled) throw err;\n            });\n        }\n    }\n    componentDidUpdate() {\n        this.scrollToHash();\n    }\n    scrollToHash() {\n        let { hash } = location;\n        hash = hash && hash.substring(1);\n        if (!hash) return;\n        const el = document.getElementById(hash);\n        if (!el) return;\n        // If we call scrollIntoView() in here without a setTimeout\n        // it won't scroll properly.\n        setTimeout(()=>el.scrollIntoView(), 0);\n    }\n    render() {\n        if (false) {} else {\n            const { ReactDevOverlay } = __webpack_require__(/*! next/dist/compiled/@next/react-dev-overlay/dist/client */ \"../node_modules/next/dist/compiled/@next/react-dev-overlay/dist/client.js\");\n            return /*#__PURE__*/ _react.default.createElement(ReactDevOverlay, null, this.props.children);\n        }\n    }\n}\nasync function initialize(opts) {\n    if (opts === void 0) opts = {};\n    _tracer.default.onSpanEnd(_reporttosocket.default);\n    // This makes sure this specific lines are removed in production\n    if (true) {\n        devClient = opts.devClient;\n    }\n    initialData = JSON.parse(document.getElementById(\"__NEXT_DATA__\").textContent);\n    window.__NEXT_DATA__ = initialData;\n    defaultLocale = initialData.defaultLocale;\n    const prefix = initialData.assetPrefix || \"\";\n    self.__next_set_public_path__(\"\" + prefix + \"/_next/\") //eslint-disable-line\n    ;\n    // Initialize next/config with the environment configuration\n    (0, _runtimeconfigexternal.setConfig)({\n        serverRuntimeConfig: {},\n        publicRuntimeConfig: initialData.runtimeConfig || {}\n    });\n    asPath = (0, _utils.getURL)();\n    // make sure not to attempt stripping basePath for 404s\n    if ((0, _hasbasepath.hasBasePath)(asPath)) {\n        asPath = (0, _removebasepath.removeBasePath)(asPath);\n    }\n    if (false) {}\n    if (initialData.scriptLoader) {\n        const { initScriptLoader } = __webpack_require__(/*! ./script */ \"../node_modules/next/dist/client/script.js\");\n        initScriptLoader(initialData.scriptLoader);\n    }\n    pageLoader = new _pageloader.default(initialData.buildId, prefix);\n    const register = (param)=>{\n        let [r, f] = param;\n        return pageLoader.routeLoader.onEntrypoint(r, f);\n    };\n    if (window.__NEXT_P) {\n        // Defer page registration for another tick. This will increase the overall\n        // latency in hydrating the page, but reduce the total blocking time.\n        window.__NEXT_P.map((p)=>setTimeout(()=>register(p), 0));\n    }\n    window.__NEXT_P = [];\n    window.__NEXT_P.push = register;\n    headManager = (0, _headmanager.default)();\n    headManager.getIsSsr = ()=>{\n        return router.isSsr;\n    };\n    appElement = document.getElementById(\"__next\");\n    return {\n        assetPrefix: prefix\n    };\n}\nfunction renderApp(App, appProps) {\n    return /*#__PURE__*/ _react.default.createElement(App, appProps);\n}\nfunction AppContainer(param) {\n    _s();\n    let { children } = param;\n    // Create a memoized value for next/navigation router context.\n    const adaptedForAppRouter = _react.default.useMemo(()=>{\n        return (0, _adapters.adaptForAppRouterInstance)(router);\n    }, []);\n    var _self___NEXT_DATA___autoExport;\n    return /*#__PURE__*/ _react.default.createElement(Container, {\n        fn: (error)=>// eslint-disable-next-line @typescript-eslint/no-use-before-define\n            renderError({\n                App: CachedApp,\n                err: error\n            }).catch((err)=>console.error(\"Error rendering page: \", err))\n    }, /*#__PURE__*/ _react.default.createElement(_approutercontextsharedruntime.AppRouterContext.Provider, {\n        value: adaptedForAppRouter\n    }, /*#__PURE__*/ _react.default.createElement(_hooksclientcontextsharedruntime.SearchParamsContext.Provider, {\n        value: (0, _adapters.adaptForSearchParams)(router)\n    }, /*#__PURE__*/ _react.default.createElement(_adapters.PathnameContextProviderAdapter, {\n        router: router,\n        isAutoExport: (_self___NEXT_DATA___autoExport = self.__NEXT_DATA__.autoExport) != null ? _self___NEXT_DATA___autoExport : false\n    }, /*#__PURE__*/ _react.default.createElement(_hooksclientcontextsharedruntime.PathParamsContext.Provider, {\n        value: (0, _adapters.adaptForPathParams)(router)\n    }, /*#__PURE__*/ _react.default.createElement(_routercontextsharedruntime.RouterContext.Provider, {\n        value: (0, _router.makePublicRouterInstance)(router)\n    }, /*#__PURE__*/ _react.default.createElement(_headmanagercontextsharedruntime.HeadManagerContext.Provider, {\n        value: headManager\n    }, /*#__PURE__*/ _react.default.createElement(_imageconfigcontextsharedruntime.ImageConfigContext.Provider, {\n        value: {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[]}\n    }, children))))))));\n}\n_s(AppContainer, \"F6BSfrFQNeqenuPnUMVY/6gI8uE=\");\n_c = AppContainer;\nconst wrapApp = (App)=>(wrappedAppProps)=>{\n        const appProps = {\n            ...wrappedAppProps,\n            Component: CachedComponent,\n            err: initialData.err,\n            router\n        };\n        return /*#__PURE__*/ _react.default.createElement(AppContainer, null, renderApp(App, appProps));\n    };\n// This method handles all runtime and debug errors.\n// 404 and 500 errors are special kind of errors\n// and they are still handle via the main render method.\nfunction renderError(renderErrorProps) {\n    let { App, err } = renderErrorProps;\n    // In development runtime errors are caught by our overlay\n    // In production we catch runtime errors using componentDidCatch which will trigger renderError\n    if (true) {\n        // A Next.js rendering runtime error is always unrecoverable\n        // FIXME: let's make this recoverable (error in GIP client-transition)\n        devClient.onUnrecoverableError();\n        // We need to render an empty <App> so that the `<ReactDevOverlay>` can\n        // render itself.\n        // TODO: Fix disabled eslint rule\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return doRender({\n            App: ()=>null,\n            props: {},\n            Component: ()=>null,\n            styleSheets: []\n        });\n    }\n    // Make sure we log the error to the console, otherwise users can't track down issues.\n    console.error(err);\n    console.error(\"A client-side exception has occurred, see here for more info: https://nextjs.org/docs/messages/client-side-exception-occurred\");\n    return pageLoader.loadPage(\"/_error\").then((param)=>{\n        let { page: ErrorComponent, styleSheets } = param;\n        return (lastAppProps == null ? void 0 : lastAppProps.Component) === ErrorComponent ? Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ../pages/_error */ \"../node_modules/next/dist/pages/_error.js\"))).then((errorModule)=>{\n            return Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ../pages/_app */ \"../node_modules/next/dist/pages/_app.js\"))).then((appModule)=>{\n                App = appModule.default;\n                renderErrorProps.App = App;\n                return errorModule;\n            });\n        }).then((m)=>({\n                ErrorComponent: m.default,\n                styleSheets: []\n            })) : {\n            ErrorComponent,\n            styleSheets\n        };\n    }).then((param)=>{\n        let { ErrorComponent, styleSheets } = param;\n        var _renderErrorProps_props;\n        // In production we do a normal render with the `ErrorComponent` as component.\n        // If we've gotten here upon initial render, we can use the props from the server.\n        // Otherwise, we need to call `getInitialProps` on `App` before mounting.\n        const AppTree = wrapApp(App);\n        const appCtx = {\n            Component: ErrorComponent,\n            AppTree,\n            router,\n            ctx: {\n                err,\n                pathname: initialData.page,\n                query: initialData.query,\n                asPath,\n                AppTree\n            }\n        };\n        return Promise.resolve(((_renderErrorProps_props = renderErrorProps.props) == null ? void 0 : _renderErrorProps_props.err) ? renderErrorProps.props : (0, _utils.loadGetInitialProps)(App, appCtx)).then((initProps)=>// eslint-disable-next-line @typescript-eslint/no-use-before-define\n            doRender({\n                ...renderErrorProps,\n                err,\n                Component: ErrorComponent,\n                styleSheets,\n                props: initProps\n            }));\n    });\n}\n// Dummy component that we render as a child of Root so that we can\n// toggle the correct styles before the page is rendered.\nfunction Head(param) {\n    _s1();\n    let { callback } = param;\n    // We use `useLayoutEffect` to guarantee the callback is executed\n    // as soon as React flushes the update.\n    _react.default.useLayoutEffect(()=>callback(), [\n        callback\n    ]);\n    return null;\n}\n_s1(Head, \"n7/vCynhJvM+pLkyL2DMQUF0odM=\");\n_c1 = Head;\nconst performanceMarks = {\n    navigationStart: \"navigationStart\",\n    beforeRender: \"beforeRender\",\n    afterRender: \"afterRender\",\n    afterHydrate: \"afterHydrate\",\n    routeChange: \"routeChange\"\n};\nconst performanceMeasures = {\n    hydration: \"Next.js-hydration\",\n    beforeHydration: \"Next.js-before-hydration\",\n    routeChangeToRender: \"Next.js-route-change-to-render\",\n    render: \"Next.js-render\"\n};\nlet reactRoot = null;\n// On initial render a hydrate should always happen\nlet shouldHydrate = true;\nfunction clearMarks() {\n    [\n        performanceMarks.beforeRender,\n        performanceMarks.afterHydrate,\n        performanceMarks.afterRender,\n        performanceMarks.routeChange\n    ].forEach((mark)=>performance.clearMarks(mark));\n}\nfunction markHydrateComplete() {\n    if (!_utils.ST) return;\n    performance.mark(performanceMarks.afterHydrate) // mark end of hydration\n    ;\n    const hasBeforeRenderMark = performance.getEntriesByName(performanceMarks.beforeRender, \"mark\").length;\n    if (hasBeforeRenderMark) {\n        const beforeHydrationMeasure = performance.measure(performanceMeasures.beforeHydration, performanceMarks.navigationStart, performanceMarks.beforeRender);\n        const hydrationMeasure = performance.measure(performanceMeasures.hydration, performanceMarks.beforeRender, performanceMarks.afterHydrate);\n        if ( true && // Old versions of Safari don't return `PerformanceMeasure`s from `performance.measure()`\n        beforeHydrationMeasure !== undefined && hydrationMeasure !== undefined) {\n            _tracer.default.startSpan(\"navigation-to-hydration\", {\n                startTime: performance.timeOrigin + beforeHydrationMeasure.startTime,\n                attributes: {\n                    pathname: location.pathname,\n                    query: location.search\n                }\n            }).end(performance.timeOrigin + hydrationMeasure.startTime + hydrationMeasure.duration);\n        }\n    }\n    if (onPerfEntry) {\n        performance.getEntriesByName(performanceMeasures.hydration).forEach(onPerfEntry);\n    }\n    clearMarks();\n}\nfunction markRenderComplete() {\n    if (!_utils.ST) return;\n    performance.mark(performanceMarks.afterRender) // mark end of render\n    ;\n    const navStartEntries = performance.getEntriesByName(performanceMarks.routeChange, \"mark\");\n    if (!navStartEntries.length) return;\n    const hasBeforeRenderMark = performance.getEntriesByName(performanceMarks.beforeRender, \"mark\").length;\n    if (hasBeforeRenderMark) {\n        performance.measure(performanceMeasures.routeChangeToRender, navStartEntries[0].name, performanceMarks.beforeRender);\n        performance.measure(performanceMeasures.render, performanceMarks.beforeRender, performanceMarks.afterRender);\n        if (onPerfEntry) {\n            performance.getEntriesByName(performanceMeasures.render).forEach(onPerfEntry);\n            performance.getEntriesByName(performanceMeasures.routeChangeToRender).forEach(onPerfEntry);\n        }\n    }\n    clearMarks();\n    [\n        performanceMeasures.routeChangeToRender,\n        performanceMeasures.render\n    ].forEach((measure)=>performance.clearMeasures(measure));\n}\nfunction renderReactElement(domEl, fn) {\n    // mark start of hydrate/render\n    if (_utils.ST) {\n        performance.mark(performanceMarks.beforeRender);\n    }\n    const reactEl = fn(shouldHydrate ? markHydrateComplete : markRenderComplete);\n    if (!reactRoot) {\n        // Unlike with createRoot, you don't need a separate root.render() call here\n        reactRoot = _client.default.hydrateRoot(domEl, reactEl, {\n            onRecoverableError: _onrecoverableerror.default\n        });\n        // TODO: Remove shouldHydrate variable when React 18 is stable as it can depend on `reactRoot` existing\n        shouldHydrate = false;\n    } else {\n        const startTransition = _react.default.startTransition;\n        startTransition(()=>{\n            reactRoot.render(reactEl);\n        });\n    }\n}\nfunction Root(param) {\n    _s2();\n    let { callbacks, children } = param;\n    // We use `useLayoutEffect` to guarantee the callbacks are executed\n    // as soon as React flushes the update\n    _react.default.useLayoutEffect(()=>callbacks.forEach((callback)=>callback()), [\n        callbacks\n    ]);\n    // We should ask to measure the Web Vitals after rendering completes so we\n    // don't cause any hydration delay:\n    _react.default.useEffect(()=>{\n        (0, _performancerelayer.default)(onPerfEntry);\n    }, []);\n    if (false) {}\n    return children;\n}\n_s2(Root, \"Gjgl5rfcc2T4sFnfEMfRvL6K4Q4=\");\n_c2 = Root;\nfunction doRender(input) {\n    let { App, Component, props, err } = input;\n    let styleSheets = \"initial\" in input ? undefined : input.styleSheets;\n    Component = Component || lastAppProps.Component;\n    props = props || lastAppProps.props;\n    const appProps = {\n        ...props,\n        Component,\n        err,\n        router\n    };\n    // lastAppProps has to be set before ReactDom.render to account for ReactDom throwing an error.\n    lastAppProps = appProps;\n    let canceled = false;\n    let resolvePromise;\n    const renderPromise = new Promise((resolve, reject)=>{\n        if (lastRenderReject) {\n            lastRenderReject();\n        }\n        resolvePromise = ()=>{\n            lastRenderReject = null;\n            resolve();\n        };\n        lastRenderReject = ()=>{\n            canceled = true;\n            lastRenderReject = null;\n            const error = new Error(\"Cancel rendering route\");\n            error.cancelled = true;\n            reject(error);\n        };\n    });\n    // This function has a return type to ensure it doesn't start returning a\n    // Promise. It should remain synchronous.\n    function onStart() {\n        if (!styleSheets || // We use `style-loader` in development, so we don't need to do anything\n        // unless we're in production:\n        \"development\" !== \"production\") {\n            return false;\n        }\n        const currentStyleTags = looseToArray(document.querySelectorAll(\"style[data-n-href]\"));\n        const currentHrefs = new Set(currentStyleTags.map((tag)=>tag.getAttribute(\"data-n-href\")));\n        const noscript = document.querySelector(\"noscript[data-n-css]\");\n        const nonce = noscript == null ? void 0 : noscript.getAttribute(\"data-n-css\");\n        styleSheets.forEach((param)=>{\n            let { href, text } = param;\n            if (!currentHrefs.has(href)) {\n                const styleTag = document.createElement(\"style\");\n                styleTag.setAttribute(\"data-n-href\", href);\n                styleTag.setAttribute(\"media\", \"x\");\n                if (nonce) {\n                    styleTag.setAttribute(\"nonce\", nonce);\n                }\n                document.head.appendChild(styleTag);\n                styleTag.appendChild(document.createTextNode(text));\n            }\n        });\n        return true;\n    }\n    function onHeadCommit() {\n        if (// unless we're in production:\n        false) {}\n        if (input.scroll) {\n            const { x, y } = input.scroll;\n            (0, _handlesmoothscroll.handleSmoothScroll)(()=>{\n                window.scrollTo(x, y);\n            });\n        }\n    }\n    function onRootCommit() {\n        resolvePromise();\n    }\n    onStart();\n    const elem = /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(Head, {\n        callback: onHeadCommit\n    }), /*#__PURE__*/ _react.default.createElement(AppContainer, null, renderApp(App, appProps), /*#__PURE__*/ _react.default.createElement(_portal.Portal, {\n        type: \"next-route-announcer\"\n    }, /*#__PURE__*/ _react.default.createElement(_routeannouncer.RouteAnnouncer, null))));\n    // We catch runtime errors using componentDidCatch which will trigger renderError\n    renderReactElement(appElement, (callback)=>/*#__PURE__*/ _react.default.createElement(Root, {\n            callbacks: [\n                callback,\n                onRootCommit\n            ]\n        },  false ? /*#__PURE__*/ 0 : elem));\n    return renderPromise;\n}\nasync function render(renderingProps) {\n    if (renderingProps.err) {\n        await renderError(renderingProps);\n        return;\n    }\n    try {\n        await doRender(renderingProps);\n    } catch (err) {\n        const renderErr = (0, _iserror.getProperError)(err);\n        // bubble up cancelation errors\n        if (renderErr.cancelled) {\n            throw renderErr;\n        }\n        if (true) {\n            // Ensure this error is displayed in the overlay in development\n            setTimeout(()=>{\n                throw renderErr;\n            });\n        }\n        await renderError({\n            ...renderingProps,\n            err: renderErr\n        });\n    }\n}\nasync function hydrate(opts) {\n    let initialErr = initialData.err;\n    try {\n        const appEntrypoint = await pageLoader.routeLoader.whenEntrypoint(\"/_app\");\n        if (\"error\" in appEntrypoint) {\n            throw appEntrypoint.error;\n        }\n        const { component: app, exports: mod } = appEntrypoint;\n        CachedApp = app;\n        if (mod && mod.reportWebVitals) {\n            onPerfEntry = (param)=>{\n                let { id, name, startTime, value, duration, entryType, entries, attribution } = param;\n                // Combines timestamp with random number for unique ID\n                const uniqueID = Date.now() + \"-\" + (Math.floor(Math.random() * (9e12 - 1)) + 1e12);\n                let perfStartEntry;\n                if (entries && entries.length) {\n                    perfStartEntry = entries[0].startTime;\n                }\n                const webVitals = {\n                    id: id || uniqueID,\n                    name,\n                    startTime: startTime || perfStartEntry,\n                    value: value == null ? duration : value,\n                    label: entryType === \"mark\" || entryType === \"measure\" ? \"custom\" : \"web-vital\"\n                };\n                if (attribution) {\n                    webVitals.attribution = attribution;\n                }\n                mod.reportWebVitals(webVitals);\n            };\n        }\n        const pageEntrypoint = // error, so we need to skip waiting for the entrypoint.\n         true && initialData.err ? {\n            error: initialData.err\n        } : await pageLoader.routeLoader.whenEntrypoint(initialData.page);\n        if (\"error\" in pageEntrypoint) {\n            throw pageEntrypoint.error;\n        }\n        CachedComponent = pageEntrypoint.component;\n        if (true) {\n            const { isValidElementType } = __webpack_require__(/*! next/dist/compiled/react-is */ \"../node_modules/next/dist/compiled/react-is/index.js\");\n            if (!isValidElementType(CachedComponent)) {\n                throw new Error('The default export is not a React Component in page: \"' + initialData.page + '\"');\n            }\n        }\n    } catch (error) {\n        // This catches errors like throwing in the top level of a module\n        initialErr = (0, _iserror.getProperError)(error);\n    }\n    if (true) {\n        const { getServerError } = __webpack_require__(/*! next/dist/compiled/@next/react-dev-overlay/dist/client */ \"../node_modules/next/dist/compiled/@next/react-dev-overlay/dist/client.js\");\n        // Server-side runtime errors need to be re-thrown on the client-side so\n        // that the overlay is rendered.\n        if (initialErr) {\n            if (initialErr === initialData.err) {\n                setTimeout(()=>{\n                    let error;\n                    try {\n                        // Generate a new error object. We `throw` it because some browsers\n                        // will set the `stack` when thrown, and we want to ensure ours is\n                        // not overridden when we re-throw it below.\n                        throw new Error(initialErr.message);\n                    } catch (e) {\n                        error = e;\n                    }\n                    error.name = initialErr.name;\n                    error.stack = initialErr.stack;\n                    throw getServerError(error, initialErr.source);\n                });\n            } else {\n                setTimeout(()=>{\n                    throw initialErr;\n                });\n            }\n        }\n    }\n    if (window.__NEXT_PRELOADREADY) {\n        await window.__NEXT_PRELOADREADY(initialData.dynamicIds);\n    }\n    router = (0, _router.createRouter)(initialData.page, initialData.query, asPath, {\n        initialProps: initialData.props,\n        pageLoader,\n        App: CachedApp,\n        Component: CachedComponent,\n        wrapApp,\n        err: initialErr,\n        isFallback: Boolean(initialData.isFallback),\n        subscription: (info, App, scroll)=>render(Object.assign({}, info, {\n                App,\n                scroll\n            })),\n        locale: initialData.locale,\n        locales: initialData.locales,\n        defaultLocale,\n        domainLocales: initialData.domainLocales,\n        isPreview: initialData.isPreview\n    });\n    initialMatchesMiddleware = await router._initialMatchesMiddlewarePromise;\n    const renderCtx = {\n        App: CachedApp,\n        initial: true,\n        Component: CachedComponent,\n        props: initialData.props,\n        err: initialErr\n    };\n    if (opts == null ? void 0 : opts.beforeRender) {\n        await opts.beforeRender();\n    }\n    render(renderCtx);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=index.js.map\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"AppContainer\");\n$RefreshReg$(_c1, \"Head\");\n$RefreshReg$(_c2, \"Root\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsbUJBQW1CLEdBQWdCOzs7Ozs7QUFDbkNBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGLEtBQU1DLENBQUFBLENBTU47QUFDQSxTQUFTTSxRQUFRQyxNQUFNLEVBQUVDLEdBQUc7SUFDeEIsSUFBSSxJQUFJQyxRQUFRRCxJQUFJWixPQUFPQyxjQUFjLENBQUNVLFFBQVFFLE1BQU07UUFDcERDLFlBQVk7UUFDWkMsS0FBS0gsR0FBRyxDQUFDQyxLQUFLO0lBQ2xCO0FBQ0o7QUFDQUgsUUFBUVIsU0FBUztJQUNiRyxTQUFTO1FBQ0wsT0FBT0E7SUFDWDtJQUNBQyxRQUFRO1FBQ0osT0FBT0E7SUFDWDtJQUNBQyxTQUFTO1FBQ0wsT0FBT0E7SUFDWDtJQUNBQyxZQUFZO1FBQ1IsT0FBT0E7SUFDWDtJQUNBQyxTQUFTO1FBQ0wsT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTU8sMkJBQTJCQyxtQkFBT0EsQ0FBQyw2R0FBeUM7QUFDbEZBLG1CQUFPQSxDQUFDLHdHQUFvQztBQUM1QyxNQUFNQyxTQUFTLFdBQVcsR0FBR0YseUJBQXlCRyxDQUFDLENBQUNGLG1CQUFPQSxDQUFDLDZDQUFPO0FBQ3ZFLE1BQU1HLFVBQVUsV0FBVyxHQUFHSix5QkFBeUJHLENBQUMsQ0FBQ0YsbUJBQU9BLENBQUMsNkRBQWtCO0FBQ25GLE1BQU1JLG1DQUFtQ0osbUJBQU9BLENBQUMsc0lBQW1EO0FBQ3BHLE1BQU1LLFFBQVEsV0FBVyxHQUFHTix5QkFBeUJHLENBQUMsQ0FBQ0YsbUJBQU9BLENBQUMsd0VBQW9CO0FBQ25GLE1BQU1NLDhCQUE4Qk4sbUJBQU9BLENBQUMsMEhBQTZDO0FBQ3pGLE1BQU1PLHNCQUFzQlAsbUJBQU9BLENBQUMsa0lBQWlEO0FBQ3JGLE1BQU1RLGFBQWFSLG1CQUFPQSxDQUFDLDhHQUF1QztBQUNsRSxNQUFNUyxlQUFlVCxtQkFBT0Es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LE1BQU07Z0JBQzFEcUY7Z0JBQ0ErSDtZQUNKO1FBQ0psSixRQUFRcEYsWUFBWW9GLE1BQU07UUFDMUJKLFNBQVNoRixZQUFZZ0YsT0FBTztRQUM1Qi9FO1FBQ0FzUixlQUFldlIsWUFBWXVSLGFBQWE7UUFDeENDLFdBQVd4UixZQUFZd1IsU0FBUztJQUNwQztJQUNBalIsMkJBQTJCLE1BQU1uRCxPQUFPcVUsZ0NBQWdDO0lBQ3hFLE1BQU1DLFlBQVk7UUFDZG5MLEtBQUs1RjtRQUNMZ1IsU0FBUztRQUNUNVEsV0FBV0Y7UUFDWE0sT0FBT25CLFlBQVltQixLQUFLO1FBQ3hCd0IsS0FBSzJNO0lBQ1Q7SUFDQSxJQUFJN0wsUUFBUSxPQUFPLEtBQUssSUFBSUEsS0FBS2dHLFlBQVksRUFBRTtRQUMzQyxNQUFNaEcsS0FBS2dHLFlBQVk7SUFDM0I7SUFDQXBHLE9BQU9xTztBQUNYO0FBRUEsSUFBSSxDQUFDLE9BQU8xVSxRQUFRMkMsT0FBTyxLQUFLLGNBQWUsT0FBTzNDLFFBQVEyQyxPQUFPLEtBQUssWUFBWTNDLFFBQVEyQyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU8zQyxRQUFRMkMsT0FBTyxDQUFDaVMsVUFBVSxLQUFLLGFBQWE7SUFDcks5VSxPQUFPQyxjQUFjLENBQUNDLFFBQVEyQyxPQUFPLEVBQUUsY0FBYztRQUFFMUMsT0FBTztJQUFLO0lBQ25FSCxPQUFPc0YsTUFBTSxDQUFDcEYsUUFBUTJDLE9BQU8sRUFBRTNDO0lBQy9CRSxPQUFPRixPQUFPLEdBQUdBLFFBQVEyQyxPQUFPO0FBQ2xDLEVBRUEsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbmRleC5qcz8zY2ExIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbCBsb2NhdGlvbiAqLyBcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIHZlcnNpb246IG51bGwsXG4gICAgcm91dGVyOiBudWxsLFxuICAgIGVtaXR0ZXI6IG51bGwsXG4gICAgaW5pdGlhbGl6ZTogbnVsbCxcbiAgICBoeWRyYXRlOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIHZlcnNpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICB9LFxuICAgIHJvdXRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByb3V0ZXI7XG4gICAgfSxcbiAgICBlbWl0dGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGVtaXR0ZXI7XG4gICAgfSxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGluaXRpYWxpemU7XG4gICAgfSxcbiAgICBoeWRyYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGh5ZHJhdGU7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xucmVxdWlyZShcIi4uL2J1aWxkL3BvbHlmaWxscy9wb2x5ZmlsbC1tb2R1bGVcIik7XG5jb25zdCBfcmVhY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBfY2xpZW50ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwicmVhY3QtZG9tL2NsaWVudFwiKSk7XG5jb25zdCBfaGVhZG1hbmFnZXJjb250ZXh0c2hhcmVkcnVudGltZSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2hlYWQtbWFuYWdlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lXCIpO1xuY29uc3QgX21pdHQgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL21pdHRcIikpO1xuY29uc3QgX3JvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWVcIik7XG5jb25zdCBfaGFuZGxlc21vb3Roc2Nyb2xsID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2hhbmRsZS1zbW9vdGgtc2Nyb2xsXCIpO1xuY29uc3QgX2lzZHluYW1pYyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1keW5hbWljXCIpO1xuY29uc3QgX3F1ZXJ5c3RyaW5nID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3F1ZXJ5c3RyaW5nXCIpO1xuY29uc3QgX3J1bnRpbWVjb25maWdleHRlcm5hbCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3J1bnRpbWUtY29uZmlnLmV4dGVybmFsXCIpO1xuY29uc3QgX3V0aWxzID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvdXRpbHNcIik7XG5jb25zdCBfcG9ydGFsID0gcmVxdWlyZShcIi4vcG9ydGFsXCIpO1xuY29uc3QgX2hlYWRtYW5hZ2VyID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwiLi9oZWFkLW1hbmFnZXJcIikpO1xuY29uc3QgX3BhZ2Vsb2FkZXIgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCIuL3BhZ2UtbG9hZGVyXCIpKTtcbmNvbnN0IF9wZXJmb3JtYW5jZXJlbGF5ZXIgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCIuL3BlcmZvcm1hbmNlLXJlbGF5ZXJcIikpO1xuY29uc3QgX3JvdXRlYW5ub3VuY2VyID0gcmVxdWlyZShcIi4vcm91dGUtYW5ub3VuY2VyXCIpO1xuY29uc3QgX3JvdXRlciA9IHJlcXVpcmUoXCIuL3JvdXRlclwiKTtcbmNvbnN0IF9pc2Vycm9yID0gcmVxdWlyZShcIi4uL2xpYi9pcy1lcnJvclwiKTtcbmNvbnN0IF9pbWFnZWNvbmZpZ2NvbnRleHRzaGFyZWRydW50aW1lID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWVcIik7XG5jb25zdCBfcmVtb3ZlYmFzZXBhdGggPSByZXF1aXJlKFwiLi9yZW1vdmUtYmFzZS1wYXRoXCIpO1xuY29uc3QgX2hhc2Jhc2VwYXRoID0gcmVxdWlyZShcIi4vaGFzLWJhc2UtcGF0aFwiKTtcbmNvbnN0IF9hcHByb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZVwiKTtcbmNvbnN0IF9hZGFwdGVycyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci9hZGFwdGVyc1wiKTtcbmNvbnN0IF9ob29rc2NsaWVudGNvbnRleHRzaGFyZWRydW50aW1lID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvaG9va3MtY2xpZW50LWNvbnRleHQuc2hhcmVkLXJ1bnRpbWVcIik7XG5jb25zdCBfb25yZWNvdmVyYWJsZWVycm9yID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwiLi9vbi1yZWNvdmVyYWJsZS1lcnJvclwiKSk7XG5jb25zdCBfdHJhY2VyID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwiLi90cmFjaW5nL3RyYWNlclwiKSk7XG5jb25zdCBfcmVwb3J0dG9zb2NrZXQgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCIuL3RyYWNpbmcvcmVwb3J0LXRvLXNvY2tldFwiKSk7XG5jb25zdCB2ZXJzaW9uID0gXCIxMy41LjJcIjtcbmxldCByb3V0ZXI7XG5jb25zdCBlbWl0dGVyID0gKDAsIF9taXR0LmRlZmF1bHQpKCk7XG5jb25zdCBsb29zZVRvQXJyYXkgPSAoaW5wdXQpPT5bXS5zbGljZS5jYWxsKGlucHV0KTtcbmxldCBpbml0aWFsRGF0YTtcbmxldCBkZWZhdWx0TG9jYWxlID0gdW5kZWZpbmVkO1xubGV0IGFzUGF0aDtcbmxldCBwYWdlTG9hZGVyO1xubGV0IGFwcEVsZW1lbnQ7XG5sZXQgaGVhZE1hbmFnZXI7XG5sZXQgaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlID0gZmFsc2U7XG5sZXQgbGFzdEFwcFByb3BzO1xubGV0IGxhc3RSZW5kZXJSZWplY3Q7XG5sZXQgZGV2Q2xpZW50O1xubGV0IENhY2hlZEFwcCwgb25QZXJmRW50cnk7XG5sZXQgQ2FjaGVkQ29tcG9uZW50O1xuY2xhc3MgQ29udGFpbmVyIGV4dGVuZHMgX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50IHtcbiAgICBjb21wb25lbnREaWRDYXRjaChjb21wb25lbnRFcnIsIGluZm8pIHtcbiAgICAgICAgdGhpcy5wcm9wcy5mbihjb21wb25lbnRFcnIsIGluZm8pO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxUb0hhc2goKTtcbiAgICAgICAgLy8gV2UgbmVlZCB0byByZXBsYWNlIHRoZSByb3V0ZXIgc3RhdGUgaWY6XG4gICAgICAgIC8vIC0gdGhlIHBhZ2Ugd2FzIChhdXRvKSBleHBvcnRlZCBhbmQgaGFzIGEgcXVlcnkgc3RyaW5nIG9yIHNlYXJjaCAoaGFzaClcbiAgICAgICAgLy8gLSBpdCB3YXMgYXV0byBleHBvcnRlZCBhbmQgaXMgYSBkeW5hbWljIHJvdXRlICh0byBwcm92aWRlIHBhcmFtcylcbiAgICAgICAgLy8gLSBpZiBpdCBpcyBhIGNsaWVudC1zaWRlIHNrZWxldG9uIChmYWxsYmFjayByZW5kZXIpXG4gICAgICAgIC8vIC0gaWYgbWlkZGxld2FyZSBtYXRjaGVzIHRoZSBjdXJyZW50IHBhZ2UgKG1heSBoYXZlIHJld3JpdGUgcGFyYW1zKVxuICAgICAgICAvLyAtIGlmIHJld3JpdGVzIGluIG5leHQuY29uZmlnLmpzIG1hdGNoIChtYXkgaGF2ZSByZXdyaXRlIHBhcmFtcylcbiAgICAgICAgaWYgKHJvdXRlci5pc1NzciAmJiAoaW5pdGlhbERhdGEuaXNGYWxsYmFjayB8fCBpbml0aWFsRGF0YS5uZXh0RXhwb3J0ICYmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocm91dGVyLnBhdGhuYW1lKSB8fCBsb2NhdGlvbi5zZWFyY2ggfHwgcHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyB8fCBpbml0aWFsTWF0Y2hlc01pZGRsZXdhcmUpIHx8IGluaXRpYWxEYXRhLnByb3BzICYmIGluaXRpYWxEYXRhLnByb3BzLl9fTl9TU0cgJiYgKGxvY2F0aW9uLnNlYXJjaCB8fCBwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTIHx8IGluaXRpYWxNYXRjaGVzTWlkZGxld2FyZSkpKSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgcXVlcnkgb24gbW91bnQgZm9yIGV4cG9ydGVkIHBhZ2VzXG4gICAgICAgICAgICByb3V0ZXIucmVwbGFjZShyb3V0ZXIucGF0aG5hbWUgKyBcIj9cIiArIFN0cmluZygoMCwgX3F1ZXJ5c3RyaW5nLmFzc2lnbikoKDAsIF9xdWVyeXN0cmluZy51cmxRdWVyeVRvU2VhcmNoUGFyYW1zKShyb3V0ZXIucXVlcnkpLCBuZXcgVVJMU2VhcmNoUGFyYW1zKGxvY2F0aW9uLnNlYXJjaCkpKSwgYXNQYXRoLCB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIC8vIFdBUk5JTkc6IGBfaGAgaXMgYW4gaW50ZXJuYWwgb3B0aW9uIGZvciBoYW5kaW5nIE5leHQuanNcbiAgICAgICAgICAgICAgICAvLyBjbGllbnQtc2lkZSBoeWRyYXRpb24uIFlvdXIgYXBwIHNob3VsZCBfbmV2ZXJfIHVzZSB0aGlzIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIEl0IG1heSBjaGFuZ2UgYXQgYW55IHRpbWUgd2l0aG91dCBub3RpY2UuXG4gICAgICAgICAgICAgICAgX2g6IDEsXG4gICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgcGFnZXMgbXVzdCB0cmlnZ2VyIHRoZSBkYXRhIGZldGNoLCBzbyB0aGUgdHJhbnNpdGlvbiBpc1xuICAgICAgICAgICAgICAgIC8vIG5vdCBzaGFsbG93LlxuICAgICAgICAgICAgICAgIC8vIE90aGVyIHBhZ2VzIChzdHJpY3RseSB1cGRhdGluZyBxdWVyeSkgaGFwcGVucyBzaGFsbG93bHksIGFzIGRhdGFcbiAgICAgICAgICAgICAgICAvLyByZXF1aXJlbWVudHMgd291bGQgYWxyZWFkeSBiZSBwcmVzZW50LlxuICAgICAgICAgICAgICAgIHNoYWxsb3c6ICFpbml0aWFsRGF0YS5pc0ZhbGxiYWNrICYmICFpbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFlcnIuY2FuY2VsbGVkKSB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKCk7XG4gICAgfVxuICAgIHNjcm9sbFRvSGFzaCgpIHtcbiAgICAgICAgbGV0IHsgaGFzaCB9ID0gbG9jYXRpb247XG4gICAgICAgIGhhc2ggPSBoYXNoICYmIGhhc2guc3Vic3RyaW5nKDEpO1xuICAgICAgICBpZiAoIWhhc2gpIHJldHVybjtcbiAgICAgICAgY29uc3QgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChoYXNoKTtcbiAgICAgICAgaWYgKCFlbCkgcmV0dXJuO1xuICAgICAgICAvLyBJZiB3ZSBjYWxsIHNjcm9sbEludG9WaWV3KCkgaW4gaGVyZSB3aXRob3V0IGEgc2V0VGltZW91dFxuICAgICAgICAvLyBpdCB3b24ndCBzY3JvbGwgcHJvcGVybHkuXG4gICAgICAgIHNldFRpbWVvdXQoKCk9PmVsLnNjcm9sbEludG9WaWV3KCksIDApO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBSZWFjdERldk92ZXJsYXkgfSA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvZGlzdC9jbGllbnRcIik7XG4gICAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJlYWN0RGV2T3ZlcmxheSwgbnVsbCwgdGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBpbml0aWFsaXplKG9wdHMpIHtcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSBvcHRzID0ge307XG4gICAgX3RyYWNlci5kZWZhdWx0Lm9uU3BhbkVuZChfcmVwb3J0dG9zb2NrZXQuZGVmYXVsdCk7XG4gICAgLy8gVGhpcyBtYWtlcyBzdXJlIHRoaXMgc3BlY2lmaWMgbGluZXMgYXJlIHJlbW92ZWQgaW4gcHJvZHVjdGlvblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgIGRldkNsaWVudCA9IG9wdHMuZGV2Q2xpZW50O1xuICAgIH1cbiAgICBpbml0aWFsRGF0YSA9IEpTT04ucGFyc2UoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJfX05FWFRfREFUQV9fXCIpLnRleHRDb250ZW50KTtcbiAgICB3aW5kb3cuX19ORVhUX0RBVEFfXyA9IGluaXRpYWxEYXRhO1xuICAgIGRlZmF1bHRMb2NhbGUgPSBpbml0aWFsRGF0YS5kZWZhdWx0TG9jYWxlO1xuICAgIGNvbnN0IHByZWZpeCA9IGluaXRpYWxEYXRhLmFzc2V0UHJlZml4IHx8IFwiXCI7XG4gICAgc2VsZi5fX25leHRfc2V0X3B1YmxpY19wYXRoX18oXCJcIiArIHByZWZpeCArIFwiL19uZXh0L1wiKSAvL2VzbGludC1kaXNhYmxlLWxpbmVcbiAgICA7XG4gICAgLy8gSW5pdGlhbGl6ZSBuZXh0L2NvbmZpZyB3aXRoIHRoZSBlbnZpcm9ubWVudCBjb25maWd1cmF0aW9uXG4gICAgKDAsIF9ydW50aW1lY29uZmlnZXh0ZXJuYWwuc2V0Q29uZmlnKSh7XG4gICAgICAgIHNlcnZlclJ1bnRpbWVDb25maWc6IHt9LFxuICAgICAgICBwdWJsaWNSdW50aW1lQ29uZmlnOiBpbml0aWFsRGF0YS5ydW50aW1lQ29uZmlnIHx8IHt9XG4gICAgfSk7XG4gICAgYXNQYXRoID0gKDAsIF91dGlscy5nZXRVUkwpKCk7XG4gICAgLy8gbWFrZSBzdXJlIG5vdCB0byBhdHRlbXB0IHN0cmlwcGluZyBiYXNlUGF0aCBmb3IgNDA0c1xuICAgIGlmICgoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShhc1BhdGgpKSB7XG4gICAgICAgIGFzUGF0aCA9ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzUGF0aCk7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIGNvbnN0IHsgbm9ybWFsaXplTG9jYWxlUGF0aCB9ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGhcIik7XG4gICAgICAgIGNvbnN0IHsgZGV0ZWN0RG9tYWluTG9jYWxlIH0gPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9pMThuL2RldGVjdC1kb21haW4tbG9jYWxlXCIpO1xuICAgICAgICBjb25zdCB7IHBhcnNlUmVsYXRpdmVVcmwgfSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9wYXJzZS1yZWxhdGl2ZS11cmxcIik7XG4gICAgICAgIGNvbnN0IHsgZm9ybWF0VXJsIH0gPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybFwiKTtcbiAgICAgICAgaWYgKGluaXRpYWxEYXRhLmxvY2FsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFzID0gcGFyc2VSZWxhdGl2ZVVybChhc1BhdGgpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9IG5vcm1hbGl6ZUxvY2FsZVBhdGgocGFyc2VkQXMucGF0aG5hbWUsIGluaXRpYWxEYXRhLmxvY2FsZXMpO1xuICAgICAgICAgICAgaWYgKGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUpIHtcbiAgICAgICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9IGxvY2FsZVBhdGhSZXN1bHQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgYXNQYXRoID0gZm9ybWF0VXJsKHBhcnNlZEFzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZGVyaXZlIHRoZSBkZWZhdWx0IGxvY2FsZSBpZiBpdCB3YXNuJ3QgZGV0ZWN0ZWQgaW4gdGhlIGFzUGF0aFxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHdlIGRvbid0IHByZXJlbmRlciBzdGF0aWMgcGFnZXMgd2l0aCBhbGwgcG9zc2libGUgZGVmYXVsdFxuICAgICAgICAgICAgICAgIC8vIGxvY2FsZXNcbiAgICAgICAgICAgICAgICBkZWZhdWx0TG9jYWxlID0gaW5pdGlhbERhdGEubG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXR0ZW1wdCBkZXRlY3RpbmcgZGVmYXVsdCBsb2NhbGUgYmFzZWQgb24gaG9zdG5hbWVcbiAgICAgICAgICAgIGNvbnN0IGRldGVjdGVkRG9tYWluID0gZGV0ZWN0RG9tYWluTG9jYWxlKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX0RPTUFJTlMsIHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBpbnZlc3RpZ2F0ZSBpZiBkZWZhdWx0TG9jYWxlIG5lZWRzIHRvIGJlIHBvcHVsYXRlZCBhZnRlclxuICAgICAgICAgICAgLy8gaHlkcmF0aW9uIHRvIHByZXZlbnQgbWlzbWF0Y2hlZCByZW5kZXJzXG4gICAgICAgICAgICBpZiAoZGV0ZWN0ZWREb21haW4pIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0TG9jYWxlID0gZGV0ZWN0ZWREb21haW4uZGVmYXVsdExvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5pdGlhbERhdGEuc2NyaXB0TG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IHsgaW5pdFNjcmlwdExvYWRlciB9ID0gcmVxdWlyZShcIi4vc2NyaXB0XCIpO1xuICAgICAgICBpbml0U2NyaXB0TG9hZGVyKGluaXRpYWxEYXRhLnNjcmlwdExvYWRlcik7XG4gICAgfVxuICAgIHBhZ2VMb2FkZXIgPSBuZXcgX3BhZ2Vsb2FkZXIuZGVmYXVsdChpbml0aWFsRGF0YS5idWlsZElkLCBwcmVmaXgpO1xuICAgIGNvbnN0IHJlZ2lzdGVyID0gKHBhcmFtKT0+e1xuICAgICAgICBsZXQgW3IsIGZdID0gcGFyYW07XG4gICAgICAgIHJldHVybiBwYWdlTG9hZGVyLnJvdXRlTG9hZGVyLm9uRW50cnlwb2ludChyLCBmKTtcbiAgICB9O1xuICAgIGlmICh3aW5kb3cuX19ORVhUX1ApIHtcbiAgICAgICAgLy8gRGVmZXIgcGFnZSByZWdpc3RyYXRpb24gZm9yIGFub3RoZXIgdGljay4gVGhpcyB3aWxsIGluY3JlYXNlIHRoZSBvdmVyYWxsXG4gICAgICAgIC8vIGxhdGVuY3kgaW4gaHlkcmF0aW5nIHRoZSBwYWdlLCBidXQgcmVkdWNlIHRoZSB0b3RhbCBibG9ja2luZyB0aW1lLlxuICAgICAgICB3aW5kb3cuX19ORVhUX1AubWFwKChwKT0+c2V0VGltZW91dCgoKT0+cmVnaXN0ZXIocCksIDApKTtcbiAgICB9XG4gICAgd2luZG93Ll9fTkVYVF9QID0gW107XG4gICAgd2luZG93Ll9fTkVYVF9QLnB1c2ggPSByZWdpc3RlcjtcbiAgICBoZWFkTWFuYWdlciA9ICgwLCBfaGVhZG1hbmFnZXIuZGVmYXVsdCkoKTtcbiAgICBoZWFkTWFuYWdlci5nZXRJc1NzciA9ICgpPT57XG4gICAgICAgIHJldHVybiByb3V0ZXIuaXNTc3I7XG4gICAgfTtcbiAgICBhcHBFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJfX25leHRcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXNzZXRQcmVmaXg6IHByZWZpeFxuICAgIH07XG59XG5mdW5jdGlvbiByZW5kZXJBcHAoQXBwLCBhcHBQcm9wcykge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQXBwLCBhcHBQcm9wcyk7XG59XG5mdW5jdGlvbiBBcHBDb250YWluZXIocGFyYW0pIHtcbiAgICBsZXQgeyBjaGlsZHJlbiB9ID0gcGFyYW07XG4gICAgLy8gQ3JlYXRlIGEgbWVtb2l6ZWQgdmFsdWUgZm9yIG5leHQvbmF2aWdhdGlvbiByb3V0ZXIgY29udGV4dC5cbiAgICBjb25zdCBhZGFwdGVkRm9yQXBwUm91dGVyID0gX3JlYWN0LmRlZmF1bHQudXNlTWVtbygoKT0+e1xuICAgICAgICByZXR1cm4gKDAsIF9hZGFwdGVycy5hZGFwdEZvckFwcFJvdXRlckluc3RhbmNlKShyb3V0ZXIpO1xuICAgIH0sIFtdKTtcbiAgICB2YXIgX3NlbGZfX19ORVhUX0RBVEFfX19hdXRvRXhwb3J0O1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ29udGFpbmVyLCB7XG4gICAgICAgIGZuOiAoZXJyb3IpPT4vLyBUT0RPOiBGaXggZGlzYWJsZWQgZXNsaW50IHJ1bGVcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgICAgIHJlbmRlckVycm9yKHtcbiAgICAgICAgICAgICAgICBBcHA6IENhY2hlZEFwcCxcbiAgICAgICAgICAgICAgICBlcnI6IGVycm9yXG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyKT0+Y29uc29sZS5lcnJvcihcIkVycm9yIHJlbmRlcmluZyBwYWdlOiBcIiwgZXJyKSlcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lLkFwcFJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IGFkYXB0ZWRGb3JBcHBSb3V0ZXJcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2hvb2tzY2xpZW50Y29udGV4dHNoYXJlZHJ1bnRpbWUuU2VhcmNoUGFyYW1zQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogKDAsIF9hZGFwdGVycy5hZGFwdEZvclNlYXJjaFBhcmFtcykocm91dGVyKVxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfYWRhcHRlcnMuUGF0aG5hbWVDb250ZXh0UHJvdmlkZXJBZGFwdGVyLCB7XG4gICAgICAgIHJvdXRlcjogcm91dGVyLFxuICAgICAgICBpc0F1dG9FeHBvcnQ6IChfc2VsZl9fX05FWFRfREFUQV9fX2F1dG9FeHBvcnQgPSBzZWxmLl9fTkVYVF9EQVRBX18uYXV0b0V4cG9ydCkgIT0gbnVsbCA/IF9zZWxmX19fTkVYVF9EQVRBX19fYXV0b0V4cG9ydCA6IGZhbHNlXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9ob29rc2NsaWVudGNvbnRleHRzaGFyZWRydW50aW1lLlBhdGhQYXJhbXNDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiAoMCwgX2FkYXB0ZXJzLmFkYXB0Rm9yUGF0aFBhcmFtcykocm91dGVyKVxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUuUm91dGVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogKDAsIF9yb3V0ZXIubWFrZVB1YmxpY1JvdXRlckluc3RhbmNlKShyb3V0ZXIpXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9oZWFkbWFuYWdlcmNvbnRleHRzaGFyZWRydW50aW1lLkhlYWRNYW5hZ2VyQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogaGVhZE1hbmFnZXJcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2ltYWdlY29uZmlnY29udGV4dHNoYXJlZHJ1bnRpbWUuSW1hZ2VDb25maWdDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBwcm9jZXNzLmVudi5fX05FWFRfSU1BR0VfT1BUU1xuICAgIH0sIGNoaWxkcmVuKSkpKSkpKSk7XG59XG5jb25zdCB3cmFwQXBwID0gKEFwcCk9Pih3cmFwcGVkQXBwUHJvcHMpPT57XG4gICAgICAgIGNvbnN0IGFwcFByb3BzID0ge1xuICAgICAgICAgICAgLi4ud3JhcHBlZEFwcFByb3BzLFxuICAgICAgICAgICAgQ29tcG9uZW50OiBDYWNoZWRDb21wb25lbnQsXG4gICAgICAgICAgICBlcnI6IGluaXRpYWxEYXRhLmVycixcbiAgICAgICAgICAgIHJvdXRlclxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEFwcENvbnRhaW5lciwgbnVsbCwgcmVuZGVyQXBwKEFwcCwgYXBwUHJvcHMpKTtcbiAgICB9O1xuLy8gVGhpcyBtZXRob2QgaGFuZGxlcyBhbGwgcnVudGltZSBhbmQgZGVidWcgZXJyb3JzLlxuLy8gNDA0IGFuZCA1MDAgZXJyb3JzIGFyZSBzcGVjaWFsIGtpbmQgb2YgZXJyb3JzXG4vLyBhbmQgdGhleSBhcmUgc3RpbGwgaGFuZGxlIHZpYSB0aGUgbWFpbiByZW5kZXIgbWV0aG9kLlxuZnVuY3Rpb24gcmVuZGVyRXJyb3IocmVuZGVyRXJyb3JQcm9wcykge1xuICAgIGxldCB7IEFwcCwgZXJyIH0gPSByZW5kZXJFcnJvclByb3BzO1xuICAgIC8vIEluIGRldmVsb3BtZW50IHJ1bnRpbWUgZXJyb3JzIGFyZSBjYXVnaHQgYnkgb3VyIG92ZXJsYXlcbiAgICAvLyBJbiBwcm9kdWN0aW9uIHdlIGNhdGNoIHJ1bnRpbWUgZXJyb3JzIHVzaW5nIGNvbXBvbmVudERpZENhdGNoIHdoaWNoIHdpbGwgdHJpZ2dlciByZW5kZXJFcnJvclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgLy8gQSBOZXh0LmpzIHJlbmRlcmluZyBydW50aW1lIGVycm9yIGlzIGFsd2F5cyB1bnJlY292ZXJhYmxlXG4gICAgICAgIC8vIEZJWE1FOiBsZXQncyBtYWtlIHRoaXMgcmVjb3ZlcmFibGUgKGVycm9yIGluIEdJUCBjbGllbnQtdHJhbnNpdGlvbilcbiAgICAgICAgZGV2Q2xpZW50Lm9uVW5yZWNvdmVyYWJsZUVycm9yKCk7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gcmVuZGVyIGFuIGVtcHR5IDxBcHA+IHNvIHRoYXQgdGhlIGA8UmVhY3REZXZPdmVybGF5PmAgY2FuXG4gICAgICAgIC8vIHJlbmRlciBpdHNlbGYuXG4gICAgICAgIC8vIFRPRE86IEZpeCBkaXNhYmxlZCBlc2xpbnQgcnVsZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBkb1JlbmRlcih7XG4gICAgICAgICAgICBBcHA6ICgpPT5udWxsLFxuICAgICAgICAgICAgcHJvcHM6IHt9LFxuICAgICAgICAgICAgQ29tcG9uZW50OiAoKT0+bnVsbCxcbiAgICAgICAgICAgIHN0eWxlU2hlZXRzOiBbXVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIHdlIGxvZyB0aGUgZXJyb3IgdG8gdGhlIGNvbnNvbGUsIG90aGVyd2lzZSB1c2VycyBjYW4ndCB0cmFjayBkb3duIGlzc3Vlcy5cbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgY29uc29sZS5lcnJvcihcIkEgY2xpZW50LXNpZGUgZXhjZXB0aW9uIGhhcyBvY2N1cnJlZCwgc2VlIGhlcmUgZm9yIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvY2xpZW50LXNpZGUtZXhjZXB0aW9uLW9jY3VycmVkXCIpO1xuICAgIHJldHVybiBwYWdlTG9hZGVyLmxvYWRQYWdlKFwiL19lcnJvclwiKS50aGVuKChwYXJhbSk9PntcbiAgICAgICAgbGV0IHsgcGFnZTogRXJyb3JDb21wb25lbnQsIHN0eWxlU2hlZXRzIH0gPSBwYXJhbTtcbiAgICAgICAgcmV0dXJuIChsYXN0QXBwUHJvcHMgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RBcHBQcm9wcy5Db21wb25lbnQpID09PSBFcnJvckNvbXBvbmVudCA/IGltcG9ydChcIi4uL3BhZ2VzL19lcnJvclwiKS50aGVuKChlcnJvck1vZHVsZSk9PntcbiAgICAgICAgICAgIHJldHVybiBpbXBvcnQoXCIuLi9wYWdlcy9fYXBwXCIpLnRoZW4oKGFwcE1vZHVsZSk9PntcbiAgICAgICAgICAgICAgICBBcHAgPSBhcHBNb2R1bGUuZGVmYXVsdDtcbiAgICAgICAgICAgICAgICByZW5kZXJFcnJvclByb3BzLkFwcCA9IEFwcDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JNb2R1bGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkudGhlbigobSk9Pih7XG4gICAgICAgICAgICAgICAgRXJyb3JDb21wb25lbnQ6IG0uZGVmYXVsdCxcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0czogW11cbiAgICAgICAgICAgIH0pKSA6IHtcbiAgICAgICAgICAgIEVycm9yQ29tcG9uZW50LFxuICAgICAgICAgICAgc3R5bGVTaGVldHNcbiAgICAgICAgfTtcbiAgICB9KS50aGVuKChwYXJhbSk9PntcbiAgICAgICAgbGV0IHsgRXJyb3JDb21wb25lbnQsIHN0eWxlU2hlZXRzIH0gPSBwYXJhbTtcbiAgICAgICAgdmFyIF9yZW5kZXJFcnJvclByb3BzX3Byb3BzO1xuICAgICAgICAvLyBJbiBwcm9kdWN0aW9uIHdlIGRvIGEgbm9ybWFsIHJlbmRlciB3aXRoIHRoZSBgRXJyb3JDb21wb25lbnRgIGFzIGNvbXBvbmVudC5cbiAgICAgICAgLy8gSWYgd2UndmUgZ290dGVuIGhlcmUgdXBvbiBpbml0aWFsIHJlbmRlciwgd2UgY2FuIHVzZSB0aGUgcHJvcHMgZnJvbSB0aGUgc2VydmVyLlxuICAgICAgICAvLyBPdGhlcndpc2UsIHdlIG5lZWQgdG8gY2FsbCBgZ2V0SW5pdGlhbFByb3BzYCBvbiBgQXBwYCBiZWZvcmUgbW91bnRpbmcuXG4gICAgICAgIGNvbnN0IEFwcFRyZWUgPSB3cmFwQXBwKEFwcCk7XG4gICAgICAgIGNvbnN0IGFwcEN0eCA9IHtcbiAgICAgICAgICAgIENvbXBvbmVudDogRXJyb3JDb21wb25lbnQsXG4gICAgICAgICAgICBBcHBUcmVlLFxuICAgICAgICAgICAgcm91dGVyLFxuICAgICAgICAgICAgY3R4OiB7XG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBpbml0aWFsRGF0YS5wYWdlLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBpbml0aWFsRGF0YS5xdWVyeSxcbiAgICAgICAgICAgICAgICBhc1BhdGgsXG4gICAgICAgICAgICAgICAgQXBwVHJlZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCgoX3JlbmRlckVycm9yUHJvcHNfcHJvcHMgPSByZW5kZXJFcnJvclByb3BzLnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX3JlbmRlckVycm9yUHJvcHNfcHJvcHMuZXJyKSA/IHJlbmRlckVycm9yUHJvcHMucHJvcHMgOiAoMCwgX3V0aWxzLmxvYWRHZXRJbml0aWFsUHJvcHMpKEFwcCwgYXBwQ3R4KSkudGhlbigoaW5pdFByb3BzKT0+Ly8gVE9ETzogRml4IGRpc2FibGVkIGVzbGludCBydWxlXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgICAgICBkb1JlbmRlcih7XG4gICAgICAgICAgICAgICAgLi4ucmVuZGVyRXJyb3JQcm9wcyxcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50OiBFcnJvckNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0cyxcbiAgICAgICAgICAgICAgICBwcm9wczogaW5pdFByb3BzXG4gICAgICAgICAgICB9KSk7XG4gICAgfSk7XG59XG4vLyBEdW1teSBjb21wb25lbnQgdGhhdCB3ZSByZW5kZXIgYXMgYSBjaGlsZCBvZiBSb290IHNvIHRoYXQgd2UgY2FuXG4vLyB0b2dnbGUgdGhlIGNvcnJlY3Qgc3R5bGVzIGJlZm9yZSB0aGUgcGFnZSBpcyByZW5kZXJlZC5cbmZ1bmN0aW9uIEhlYWQocGFyYW0pIHtcbiAgICBsZXQgeyBjYWxsYmFjayB9ID0gcGFyYW07XG4gICAgLy8gV2UgdXNlIGB1c2VMYXlvdXRFZmZlY3RgIHRvIGd1YXJhbnRlZSB0aGUgY2FsbGJhY2sgaXMgZXhlY3V0ZWRcbiAgICAvLyBhcyBzb29uIGFzIFJlYWN0IGZsdXNoZXMgdGhlIHVwZGF0ZS5cbiAgICBfcmVhY3QuZGVmYXVsdC51c2VMYXlvdXRFZmZlY3QoKCk9PmNhbGxiYWNrKCksIFtcbiAgICAgICAgY2FsbGJhY2tcbiAgICBdKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbmNvbnN0IHBlcmZvcm1hbmNlTWFya3MgPSB7XG4gICAgbmF2aWdhdGlvblN0YXJ0OiBcIm5hdmlnYXRpb25TdGFydFwiLFxuICAgIGJlZm9yZVJlbmRlcjogXCJiZWZvcmVSZW5kZXJcIixcbiAgICBhZnRlclJlbmRlcjogXCJhZnRlclJlbmRlclwiLFxuICAgIGFmdGVySHlkcmF0ZTogXCJhZnRlckh5ZHJhdGVcIixcbiAgICByb3V0ZUNoYW5nZTogXCJyb3V0ZUNoYW5nZVwiXG59O1xuY29uc3QgcGVyZm9ybWFuY2VNZWFzdXJlcyA9IHtcbiAgICBoeWRyYXRpb246IFwiTmV4dC5qcy1oeWRyYXRpb25cIixcbiAgICBiZWZvcmVIeWRyYXRpb246IFwiTmV4dC5qcy1iZWZvcmUtaHlkcmF0aW9uXCIsXG4gICAgcm91dGVDaGFuZ2VUb1JlbmRlcjogXCJOZXh0LmpzLXJvdXRlLWNoYW5nZS10by1yZW5kZXJcIixcbiAgICByZW5kZXI6IFwiTmV4dC5qcy1yZW5kZXJcIlxufTtcbmxldCByZWFjdFJvb3QgPSBudWxsO1xuLy8gT24gaW5pdGlhbCByZW5kZXIgYSBoeWRyYXRlIHNob3VsZCBhbHdheXMgaGFwcGVuXG5sZXQgc2hvdWxkSHlkcmF0ZSA9IHRydWU7XG5mdW5jdGlvbiBjbGVhck1hcmtzKCkge1xuICAgIFtcbiAgICAgICAgcGVyZm9ybWFuY2VNYXJrcy5iZWZvcmVSZW5kZXIsXG4gICAgICAgIHBlcmZvcm1hbmNlTWFya3MuYWZ0ZXJIeWRyYXRlLFxuICAgICAgICBwZXJmb3JtYW5jZU1hcmtzLmFmdGVyUmVuZGVyLFxuICAgICAgICBwZXJmb3JtYW5jZU1hcmtzLnJvdXRlQ2hhbmdlXG4gICAgXS5mb3JFYWNoKChtYXJrKT0+cGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhtYXJrKSk7XG59XG5mdW5jdGlvbiBtYXJrSHlkcmF0ZUNvbXBsZXRlKCkge1xuICAgIGlmICghX3V0aWxzLlNUKSByZXR1cm47XG4gICAgcGVyZm9ybWFuY2UubWFyayhwZXJmb3JtYW5jZU1hcmtzLmFmdGVySHlkcmF0ZSkgLy8gbWFyayBlbmQgb2YgaHlkcmF0aW9uXG4gICAgO1xuICAgIGNvbnN0IGhhc0JlZm9yZVJlbmRlck1hcmsgPSBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKHBlcmZvcm1hbmNlTWFya3MuYmVmb3JlUmVuZGVyLCBcIm1hcmtcIikubGVuZ3RoO1xuICAgIGlmIChoYXNCZWZvcmVSZW5kZXJNYXJrKSB7XG4gICAgICAgIGNvbnN0IGJlZm9yZUh5ZHJhdGlvbk1lYXN1cmUgPSBwZXJmb3JtYW5jZS5tZWFzdXJlKHBlcmZvcm1hbmNlTWVhc3VyZXMuYmVmb3JlSHlkcmF0aW9uLCBwZXJmb3JtYW5jZU1hcmtzLm5hdmlnYXRpb25TdGFydCwgcGVyZm9ybWFuY2VNYXJrcy5iZWZvcmVSZW5kZXIpO1xuICAgICAgICBjb25zdCBoeWRyYXRpb25NZWFzdXJlID0gcGVyZm9ybWFuY2UubWVhc3VyZShwZXJmb3JtYW5jZU1lYXN1cmVzLmh5ZHJhdGlvbiwgcGVyZm9ybWFuY2VNYXJrcy5iZWZvcmVSZW5kZXIsIHBlcmZvcm1hbmNlTWFya3MuYWZ0ZXJIeWRyYXRlKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIgJiYgLy8gT2xkIHZlcnNpb25zIG9mIFNhZmFyaSBkb24ndCByZXR1cm4gYFBlcmZvcm1hbmNlTWVhc3VyZWBzIGZyb20gYHBlcmZvcm1hbmNlLm1lYXN1cmUoKWBcbiAgICAgICAgYmVmb3JlSHlkcmF0aW9uTWVhc3VyZSAhPT0gdW5kZWZpbmVkICYmIGh5ZHJhdGlvbk1lYXN1cmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgX3RyYWNlci5kZWZhdWx0LnN0YXJ0U3BhbihcIm5hdmlnYXRpb24tdG8taHlkcmF0aW9uXCIsIHtcbiAgICAgICAgICAgICAgICBzdGFydFRpbWU6IHBlcmZvcm1hbmNlLnRpbWVPcmlnaW4gKyBiZWZvcmVIeWRyYXRpb25NZWFzdXJlLnN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IGxvY2F0aW9uLnNlYXJjaFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmVuZChwZXJmb3JtYW5jZS50aW1lT3JpZ2luICsgaHlkcmF0aW9uTWVhc3VyZS5zdGFydFRpbWUgKyBoeWRyYXRpb25NZWFzdXJlLmR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob25QZXJmRW50cnkpIHtcbiAgICAgICAgcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZShwZXJmb3JtYW5jZU1lYXN1cmVzLmh5ZHJhdGlvbikuZm9yRWFjaChvblBlcmZFbnRyeSk7XG4gICAgfVxuICAgIGNsZWFyTWFya3MoKTtcbn1cbmZ1bmN0aW9uIG1hcmtSZW5kZXJDb21wbGV0ZSgpIHtcbiAgICBpZiAoIV91dGlscy5TVCkgcmV0dXJuO1xuICAgIHBlcmZvcm1hbmNlLm1hcmsocGVyZm9ybWFuY2VNYXJrcy5hZnRlclJlbmRlcikgLy8gbWFyayBlbmQgb2YgcmVuZGVyXG4gICAgO1xuICAgIGNvbnN0IG5hdlN0YXJ0RW50cmllcyA9IHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUocGVyZm9ybWFuY2VNYXJrcy5yb3V0ZUNoYW5nZSwgXCJtYXJrXCIpO1xuICAgIGlmICghbmF2U3RhcnRFbnRyaWVzLmxlbmd0aCkgcmV0dXJuO1xuICAgIGNvbnN0IGhhc0JlZm9yZVJlbmRlck1hcmsgPSBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKHBlcmZvcm1hbmNlTWFya3MuYmVmb3JlUmVuZGVyLCBcIm1hcmtcIikubGVuZ3RoO1xuICAgIGlmIChoYXNCZWZvcmVSZW5kZXJNYXJrKSB7XG4gICAgICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUocGVyZm9ybWFuY2VNZWFzdXJlcy5yb3V0ZUNoYW5nZVRvUmVuZGVyLCBuYXZTdGFydEVudHJpZXNbMF0ubmFtZSwgcGVyZm9ybWFuY2VNYXJrcy5iZWZvcmVSZW5kZXIpO1xuICAgICAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKHBlcmZvcm1hbmNlTWVhc3VyZXMucmVuZGVyLCBwZXJmb3JtYW5jZU1hcmtzLmJlZm9yZVJlbmRlciwgcGVyZm9ybWFuY2VNYXJrcy5hZnRlclJlbmRlcik7XG4gICAgICAgIGlmIChvblBlcmZFbnRyeSkge1xuICAgICAgICAgICAgcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZShwZXJmb3JtYW5jZU1lYXN1cmVzLnJlbmRlcikuZm9yRWFjaChvblBlcmZFbnRyeSk7XG4gICAgICAgICAgICBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKHBlcmZvcm1hbmNlTWVhc3VyZXMucm91dGVDaGFuZ2VUb1JlbmRlcikuZm9yRWFjaChvblBlcmZFbnRyeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXJNYXJrcygpO1xuICAgIFtcbiAgICAgICAgcGVyZm9ybWFuY2VNZWFzdXJlcy5yb3V0ZUNoYW5nZVRvUmVuZGVyLFxuICAgICAgICBwZXJmb3JtYW5jZU1lYXN1cmVzLnJlbmRlclxuICAgIF0uZm9yRWFjaCgobWVhc3VyZSk9PnBlcmZvcm1hbmNlLmNsZWFyTWVhc3VyZXMobWVhc3VyZSkpO1xufVxuZnVuY3Rpb24gcmVuZGVyUmVhY3RFbGVtZW50KGRvbUVsLCBmbikge1xuICAgIC8vIG1hcmsgc3RhcnQgb2YgaHlkcmF0ZS9yZW5kZXJcbiAgICBpZiAoX3V0aWxzLlNUKSB7XG4gICAgICAgIHBlcmZvcm1hbmNlLm1hcmsocGVyZm9ybWFuY2VNYXJrcy5iZWZvcmVSZW5kZXIpO1xuICAgIH1cbiAgICBjb25zdCByZWFjdEVsID0gZm4oc2hvdWxkSHlkcmF0ZSA/IG1hcmtIeWRyYXRlQ29tcGxldGUgOiBtYXJrUmVuZGVyQ29tcGxldGUpO1xuICAgIGlmICghcmVhY3RSb290KSB7XG4gICAgICAgIC8vIFVubGlrZSB3aXRoIGNyZWF0ZVJvb3QsIHlvdSBkb24ndCBuZWVkIGEgc2VwYXJhdGUgcm9vdC5yZW5kZXIoKSBjYWxsIGhlcmVcbiAgICAgICAgcmVhY3RSb290ID0gX2NsaWVudC5kZWZhdWx0Lmh5ZHJhdGVSb290KGRvbUVsLCByZWFjdEVsLCB7XG4gICAgICAgICAgICBvblJlY292ZXJhYmxlRXJyb3I6IF9vbnJlY292ZXJhYmxlZXJyb3IuZGVmYXVsdFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIHNob3VsZEh5ZHJhdGUgdmFyaWFibGUgd2hlbiBSZWFjdCAxOCBpcyBzdGFibGUgYXMgaXQgY2FuIGRlcGVuZCBvbiBgcmVhY3RSb290YCBleGlzdGluZ1xuICAgICAgICBzaG91bGRIeWRyYXRlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUcmFuc2l0aW9uID0gX3JlYWN0LmRlZmF1bHQuc3RhcnRUcmFuc2l0aW9uO1xuICAgICAgICBzdGFydFRyYW5zaXRpb24oKCk9PntcbiAgICAgICAgICAgIHJlYWN0Um9vdC5yZW5kZXIocmVhY3RFbCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIFJvb3QocGFyYW0pIHtcbiAgICBsZXQgeyBjYWxsYmFja3MsIGNoaWxkcmVuIH0gPSBwYXJhbTtcbiAgICAvLyBXZSB1c2UgYHVzZUxheW91dEVmZmVjdGAgdG8gZ3VhcmFudGVlIHRoZSBjYWxsYmFja3MgYXJlIGV4ZWN1dGVkXG4gICAgLy8gYXMgc29vbiBhcyBSZWFjdCBmbHVzaGVzIHRoZSB1cGRhdGVcbiAgICBfcmVhY3QuZGVmYXVsdC51c2VMYXlvdXRFZmZlY3QoKCk9PmNhbGxiYWNrcy5mb3JFYWNoKChjYWxsYmFjayk9PmNhbGxiYWNrKCkpLCBbXG4gICAgICAgIGNhbGxiYWNrc1xuICAgIF0pO1xuICAgIC8vIFdlIHNob3VsZCBhc2sgdG8gbWVhc3VyZSB0aGUgV2ViIFZpdGFscyBhZnRlciByZW5kZXJpbmcgY29tcGxldGVzIHNvIHdlXG4gICAgLy8gZG9uJ3QgY2F1c2UgYW55IGh5ZHJhdGlvbiBkZWxheTpcbiAgICBfcmVhY3QuZGVmYXVsdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgKDAsIF9wZXJmb3JtYW5jZXJlbGF5ZXIuZGVmYXVsdCkob25QZXJmRW50cnkpO1xuICAgIH0sIFtdKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1RFU1RfTU9ERSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICAgICAgX3JlYWN0LmRlZmF1bHQudXNlRWZmZWN0KCgpPT57XG4gICAgICAgICAgICB3aW5kb3cuX19ORVhUX0hZRFJBVEVEID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuX19ORVhUX0hZRFJBVEVEX0NCKSB7XG4gICAgICAgICAgICAgICAgd2luZG93Ll9fTkVYVF9IWURSQVRFRF9DQigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbXSk7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlbjtcbn1cbmZ1bmN0aW9uIGRvUmVuZGVyKGlucHV0KSB7XG4gICAgbGV0IHsgQXBwLCBDb21wb25lbnQsIHByb3BzLCBlcnIgfSA9IGlucHV0O1xuICAgIGxldCBzdHlsZVNoZWV0cyA9IFwiaW5pdGlhbFwiIGluIGlucHV0ID8gdW5kZWZpbmVkIDogaW5wdXQuc3R5bGVTaGVldHM7XG4gICAgQ29tcG9uZW50ID0gQ29tcG9uZW50IHx8IGxhc3RBcHBQcm9wcy5Db21wb25lbnQ7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCBsYXN0QXBwUHJvcHMucHJvcHM7XG4gICAgY29uc3QgYXBwUHJvcHMgPSB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIGVycixcbiAgICAgICAgcm91dGVyXG4gICAgfTtcbiAgICAvLyBsYXN0QXBwUHJvcHMgaGFzIHRvIGJlIHNldCBiZWZvcmUgUmVhY3REb20ucmVuZGVyIHRvIGFjY291bnQgZm9yIFJlYWN0RG9tIHRocm93aW5nIGFuIGVycm9yLlxuICAgIGxhc3RBcHBQcm9wcyA9IGFwcFByb3BzO1xuICAgIGxldCBjYW5jZWxlZCA9IGZhbHNlO1xuICAgIGxldCByZXNvbHZlUHJvbWlzZTtcbiAgICBjb25zdCByZW5kZXJQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgaWYgKGxhc3RSZW5kZXJSZWplY3QpIHtcbiAgICAgICAgICAgIGxhc3RSZW5kZXJSZWplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlUHJvbWlzZSA9ICgpPT57XG4gICAgICAgICAgICBsYXN0UmVuZGVyUmVqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGFzdFJlbmRlclJlamVjdCA9ICgpPT57XG4gICAgICAgICAgICBjYW5jZWxlZCA9IHRydWU7XG4gICAgICAgICAgICBsYXN0UmVuZGVyUmVqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwiQ2FuY2VsIHJlbmRlcmluZyByb3V0ZVwiKTtcbiAgICAgICAgICAgIGVycm9yLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaGFzIGEgcmV0dXJuIHR5cGUgdG8gZW5zdXJlIGl0IGRvZXNuJ3Qgc3RhcnQgcmV0dXJuaW5nIGFcbiAgICAvLyBQcm9taXNlLiBJdCBzaG91bGQgcmVtYWluIHN5bmNocm9ub3VzLlxuICAgIGZ1bmN0aW9uIG9uU3RhcnQoKSB7XG4gICAgICAgIGlmICghc3R5bGVTaGVldHMgfHwgLy8gV2UgdXNlIGBzdHlsZS1sb2FkZXJgIGluIGRldmVsb3BtZW50LCBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nXG4gICAgICAgIC8vIHVubGVzcyB3ZSdyZSBpbiBwcm9kdWN0aW9uOlxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50U3R5bGVUYWdzID0gbG9vc2VUb0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJzdHlsZVtkYXRhLW4taHJlZl1cIikpO1xuICAgICAgICBjb25zdCBjdXJyZW50SHJlZnMgPSBuZXcgU2V0KGN1cnJlbnRTdHlsZVRhZ3MubWFwKCh0YWcpPT50YWcuZ2V0QXR0cmlidXRlKFwiZGF0YS1uLWhyZWZcIikpKTtcbiAgICAgICAgY29uc3Qgbm9zY3JpcHQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibm9zY3JpcHRbZGF0YS1uLWNzc11cIik7XG4gICAgICAgIGNvbnN0IG5vbmNlID0gbm9zY3JpcHQgPT0gbnVsbCA/IHZvaWQgMCA6IG5vc2NyaXB0LmdldEF0dHJpYnV0ZShcImRhdGEtbi1jc3NcIik7XG4gICAgICAgIHN0eWxlU2hlZXRzLmZvckVhY2goKHBhcmFtKT0+e1xuICAgICAgICAgICAgbGV0IHsgaHJlZiwgdGV4dCB9ID0gcGFyYW07XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRIcmVmcy5oYXMoaHJlZikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZVRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgICAgICAgICAgICBzdHlsZVRhZy5zZXRBdHRyaWJ1dGUoXCJkYXRhLW4taHJlZlwiLCBocmVmKTtcbiAgICAgICAgICAgICAgICBzdHlsZVRhZy5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBcInhcIik7XG4gICAgICAgICAgICAgICAgaWYgKG5vbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlVGFnLnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZVRhZyk7XG4gICAgICAgICAgICAgICAgc3R5bGVUYWcuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uSGVhZENvbW1pdCgpIHtcbiAgICAgICAgaWYgKC8vIFdlIHVzZSBgc3R5bGUtbG9hZGVyYCBpbiBkZXZlbG9wbWVudCwgc28gd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZ1xuICAgICAgICAvLyB1bmxlc3Mgd2UncmUgaW4gcHJvZHVjdGlvbjpcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiICYmIC8vIFdlIGNhbiBza2lwIHRoaXMgZHVyaW5nIGh5ZHJhdGlvbi4gUnVubmluZyBpdCB3b250IGNhdXNlIGFueSBoYXJtLCBidXRcbiAgICAgICAgLy8gd2UgbWF5IGFzIHdlbGwgc2F2ZSB0aGUgQ1BVIGN5Y2xlczpcbiAgICAgICAgc3R5bGVTaGVldHMgJiYgLy8gRW5zdXJlIHRoaXMgcmVuZGVyIHdhcyBub3QgY2FuY2VsZWRcbiAgICAgICAgIWNhbmNlbGVkKSB7XG4gICAgICAgICAgICBjb25zdCBkZXNpcmVkSHJlZnMgPSBuZXcgU2V0KHN0eWxlU2hlZXRzLm1hcCgocyk9PnMuaHJlZikpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFN0eWxlVGFncyA9IGxvb3NlVG9BcnJheShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwic3R5bGVbZGF0YS1uLWhyZWZdXCIpKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRIcmVmcyA9IGN1cnJlbnRTdHlsZVRhZ3MubWFwKCh0YWcpPT50YWcuZ2V0QXR0cmlidXRlKFwiZGF0YS1uLWhyZWZcIikpO1xuICAgICAgICAgICAgLy8gVG9nZ2xlIGA8c3R5bGU+YCB0YWdzIG9uIG9yIG9mZiBkZXBlbmRpbmcgb24gaWYgdGhleSdyZSBuZWVkZWQ6XG4gICAgICAgICAgICBmb3IobGV0IGlkeCA9IDA7IGlkeCA8IGN1cnJlbnRIcmVmcy5sZW5ndGg7ICsraWR4KXtcbiAgICAgICAgICAgICAgICBpZiAoZGVzaXJlZEhyZWZzLmhhcyhjdXJyZW50SHJlZnNbaWR4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0eWxlVGFnc1tpZHhdLnJlbW92ZUF0dHJpYnV0ZShcIm1lZGlhXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdHlsZVRhZ3NbaWR4XS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBcInhcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVvcmRlciBzdHlsZXMgaW50byBpbnRlbmRlZCBvcmRlcjpcbiAgICAgICAgICAgIGxldCByZWZlcmVuY2VOb2RlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIm5vc2NyaXB0W2RhdGEtbi1jc3NdXCIpO1xuICAgICAgICAgICAgaWYgKC8vIFRoaXMgc2hvdWxkIGJlIGFuIGludmFyaWFudDpcbiAgICAgICAgICAgIHJlZmVyZW5jZU5vZGUpIHtcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0cy5mb3JFYWNoKChwYXJhbSk9PntcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgaHJlZiB9ID0gcGFyYW07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFRhZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlW2RhdGEtbi1ocmVmPVwiJyArIGhyZWYgKyAnXCJdJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgvLyBUaGlzIHNob3VsZCBiZSBhbiBpbnZhcmlhbnQ6XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0YXJnZXRUYWcsIHJlZmVyZW5jZU5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZSA9IHRhcmdldFRhZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmluYWxseSwgY2xlYW4gdXAgc2VydmVyIHJlbmRlcmVkIHN0eWxlc2hlZXRzOlxuICAgICAgICAgICAgbG9vc2VUb0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rW2RhdGEtbi1wXVwiKSkuZm9yRWFjaCgoZWwpPT57XG4gICAgICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQuc2Nyb2xsKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGlucHV0LnNjcm9sbDtcbiAgICAgICAgICAgICgwLCBfaGFuZGxlc21vb3Roc2Nyb2xsLmhhbmRsZVNtb290aFNjcm9sbCkoKCk9PntcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oeCwgeSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvblJvb3RDb21taXQoKSB7XG4gICAgICAgIHJlc29sdmVQcm9taXNlKCk7XG4gICAgfVxuICAgIG9uU3RhcnQoKTtcbiAgICBjb25zdCBlbGVtID0gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSGVhZCwge1xuICAgICAgICBjYWxsYmFjazogb25IZWFkQ29tbWl0XG4gICAgfSksIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChBcHBDb250YWluZXIsIG51bGwsIHJlbmRlckFwcChBcHAsIGFwcFByb3BzKSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9wb3J0YWwuUG9ydGFsLCB7XG4gICAgICAgIHR5cGU6IFwibmV4dC1yb3V0ZS1hbm5vdW5jZXJcIlxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcm91dGVhbm5vdW5jZXIuUm91dGVBbm5vdW5jZXIsIG51bGwpKSkpO1xuICAgIC8vIFdlIGNhdGNoIHJ1bnRpbWUgZXJyb3JzIHVzaW5nIGNvbXBvbmVudERpZENhdGNoIHdoaWNoIHdpbGwgdHJpZ2dlciByZW5kZXJFcnJvclxuICAgIHJlbmRlclJlYWN0RWxlbWVudChhcHBFbGVtZW50LCAoY2FsbGJhY2spPT4vKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUm9vdCwge1xuICAgICAgICAgICAgY2FsbGJhY2tzOiBbXG4gICAgICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgb25Sb290Q29tbWl0XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sIHByb2Nlc3MuZW52Ll9fTkVYVF9TVFJJQ1RfTU9ERSA/IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5TdHJpY3RNb2RlLCBudWxsLCBlbGVtKSA6IGVsZW0pKTtcbiAgICByZXR1cm4gcmVuZGVyUHJvbWlzZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlbmRlcihyZW5kZXJpbmdQcm9wcykge1xuICAgIGlmIChyZW5kZXJpbmdQcm9wcy5lcnIpIHtcbiAgICAgICAgYXdhaXQgcmVuZGVyRXJyb3IocmVuZGVyaW5nUHJvcHMpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGRvUmVuZGVyKHJlbmRlcmluZ1Byb3BzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgcmVuZGVyRXJyID0gKDAsIF9pc2Vycm9yLmdldFByb3BlckVycm9yKShlcnIpO1xuICAgICAgICAvLyBidWJibGUgdXAgY2FuY2VsYXRpb24gZXJyb3JzXG4gICAgICAgIGlmIChyZW5kZXJFcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICB0aHJvdyByZW5kZXJFcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGlzIGVycm9yIGlzIGRpc3BsYXllZCBpbiB0aGUgb3ZlcmxheSBpbiBkZXZlbG9wbWVudFxuICAgICAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgIHRocm93IHJlbmRlckVycjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJlbmRlckVycm9yKHtcbiAgICAgICAgICAgIC4uLnJlbmRlcmluZ1Byb3BzLFxuICAgICAgICAgICAgZXJyOiByZW5kZXJFcnJcbiAgICAgICAgfSk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gaHlkcmF0ZShvcHRzKSB7XG4gICAgbGV0IGluaXRpYWxFcnIgPSBpbml0aWFsRGF0YS5lcnI7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYXBwRW50cnlwb2ludCA9IGF3YWl0IHBhZ2VMb2FkZXIucm91dGVMb2FkZXIud2hlbkVudHJ5cG9pbnQoXCIvX2FwcFwiKTtcbiAgICAgICAgaWYgKFwiZXJyb3JcIiBpbiBhcHBFbnRyeXBvaW50KSB7XG4gICAgICAgICAgICB0aHJvdyBhcHBFbnRyeXBvaW50LmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY29tcG9uZW50OiBhcHAsIGV4cG9ydHM6IG1vZCB9ID0gYXBwRW50cnlwb2ludDtcbiAgICAgICAgQ2FjaGVkQXBwID0gYXBwO1xuICAgICAgICBpZiAobW9kICYmIG1vZC5yZXBvcnRXZWJWaXRhbHMpIHtcbiAgICAgICAgICAgIG9uUGVyZkVudHJ5ID0gKHBhcmFtKT0+e1xuICAgICAgICAgICAgICAgIGxldCB7IGlkLCBuYW1lLCBzdGFydFRpbWUsIHZhbHVlLCBkdXJhdGlvbiwgZW50cnlUeXBlLCBlbnRyaWVzLCBhdHRyaWJ1dGlvbiB9ID0gcGFyYW07XG4gICAgICAgICAgICAgICAgLy8gQ29tYmluZXMgdGltZXN0YW1wIHdpdGggcmFuZG9tIG51bWJlciBmb3IgdW5pcXVlIElEXG4gICAgICAgICAgICAgICAgY29uc3QgdW5pcXVlSUQgPSBEYXRlLm5vdygpICsgXCItXCIgKyAoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKDllMTIgLSAxKSkgKyAxZTEyKTtcbiAgICAgICAgICAgICAgICBsZXQgcGVyZlN0YXJ0RW50cnk7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJpZXMgJiYgZW50cmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVyZlN0YXJ0RW50cnkgPSBlbnRyaWVzWzBdLnN0YXJ0VGltZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgd2ViVml0YWxzID0ge1xuICAgICAgICAgICAgICAgICAgICBpZDogaWQgfHwgdW5pcXVlSUQsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lIHx8IHBlcmZTdGFydEVudHJ5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUgPT0gbnVsbCA/IGR1cmF0aW9uIDogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBlbnRyeVR5cGUgPT09IFwibWFya1wiIHx8IGVudHJ5VHlwZSA9PT0gXCJtZWFzdXJlXCIgPyBcImN1c3RvbVwiIDogXCJ3ZWItdml0YWxcIlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHdlYlZpdGFscy5hdHRyaWJ1dGlvbiA9IGF0dHJpYnV0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb2QucmVwb3J0V2ViVml0YWxzKHdlYlZpdGFscyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhZ2VFbnRyeXBvaW50ID0gLy8gVGhlIGRldiBzZXJ2ZXIgZmFpbHMgdG8gc2VydmUgc2NyaXB0IGFzc2V0cyB3aGVuIHRoZXJlJ3MgYSBoeWRyYXRpb25cbiAgICAgICAgLy8gZXJyb3IsIHNvIHdlIG5lZWQgdG8gc2tpcCB3YWl0aW5nIGZvciB0aGUgZW50cnlwb2ludC5cbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIiAmJiBpbml0aWFsRGF0YS5lcnIgPyB7XG4gICAgICAgICAgICBlcnJvcjogaW5pdGlhbERhdGEuZXJyXG4gICAgICAgIH0gOiBhd2FpdCBwYWdlTG9hZGVyLnJvdXRlTG9hZGVyLndoZW5FbnRyeXBvaW50KGluaXRpYWxEYXRhLnBhZ2UpO1xuICAgICAgICBpZiAoXCJlcnJvclwiIGluIHBhZ2VFbnRyeXBvaW50KSB7XG4gICAgICAgICAgICB0aHJvdyBwYWdlRW50cnlwb2ludC5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBDYWNoZWRDb21wb25lbnQgPSBwYWdlRW50cnlwb2ludC5jb21wb25lbnQ7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlIH0gPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWlzXCIpO1xuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUoQ2FjaGVkQ29tcG9uZW50KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRlZmF1bHQgZXhwb3J0IGlzIG5vdCBhIFJlYWN0IENvbXBvbmVudCBpbiBwYWdlOiBcIicgKyBpbml0aWFsRGF0YS5wYWdlICsgJ1wiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBUaGlzIGNhdGNoZXMgZXJyb3JzIGxpa2UgdGhyb3dpbmcgaW4gdGhlIHRvcCBsZXZlbCBvZiBhIG1vZHVsZVxuICAgICAgICBpbml0aWFsRXJyID0gKDAsIF9pc2Vycm9yLmdldFByb3BlckVycm9yKShlcnJvcik7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgIGNvbnN0IHsgZ2V0U2VydmVyRXJyb3IgfSA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvZGlzdC9jbGllbnRcIik7XG4gICAgICAgIC8vIFNlcnZlci1zaWRlIHJ1bnRpbWUgZXJyb3JzIG5lZWQgdG8gYmUgcmUtdGhyb3duIG9uIHRoZSBjbGllbnQtc2lkZSBzb1xuICAgICAgICAvLyB0aGF0IHRoZSBvdmVybGF5IGlzIHJlbmRlcmVkLlxuICAgICAgICBpZiAoaW5pdGlhbEVycikge1xuICAgICAgICAgICAgaWYgKGluaXRpYWxFcnIgPT09IGluaXRpYWxEYXRhLmVycikge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBuZXcgZXJyb3Igb2JqZWN0LiBXZSBgdGhyb3dgIGl0IGJlY2F1c2Ugc29tZSBicm93c2Vyc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBzZXQgdGhlIGBzdGFja2Agd2hlbiB0aHJvd24sIGFuZCB3ZSB3YW50IHRvIGVuc3VyZSBvdXJzIGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3Qgb3ZlcnJpZGRlbiB3aGVuIHdlIHJlLXRocm93IGl0IGJlbG93LlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGluaXRpYWxFcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlcnJvci5uYW1lID0gaW5pdGlhbEVyci5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5zdGFjayA9IGluaXRpYWxFcnIuc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGdldFNlcnZlckVycm9yKGVycm9yLCBpbml0aWFsRXJyLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgaW5pdGlhbEVycjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAod2luZG93Ll9fTkVYVF9QUkVMT0FEUkVBRFkpIHtcbiAgICAgICAgYXdhaXQgd2luZG93Ll9fTkVYVF9QUkVMT0FEUkVBRFkoaW5pdGlhbERhdGEuZHluYW1pY0lkcyk7XG4gICAgfVxuICAgIHJvdXRlciA9ICgwLCBfcm91dGVyLmNyZWF0ZVJvdXRlcikoaW5pdGlhbERhdGEucGFnZSwgaW5pdGlhbERhdGEucXVlcnksIGFzUGF0aCwge1xuICAgICAgICBpbml0aWFsUHJvcHM6IGluaXRpYWxEYXRhLnByb3BzLFxuICAgICAgICBwYWdlTG9hZGVyLFxuICAgICAgICBBcHA6IENhY2hlZEFwcCxcbiAgICAgICAgQ29tcG9uZW50OiBDYWNoZWRDb21wb25lbnQsXG4gICAgICAgIHdyYXBBcHAsXG4gICAgICAgIGVycjogaW5pdGlhbEVycixcbiAgICAgICAgaXNGYWxsYmFjazogQm9vbGVhbihpbml0aWFsRGF0YS5pc0ZhbGxiYWNrKSxcbiAgICAgICAgc3Vic2NyaXB0aW9uOiAoaW5mbywgQXBwLCBzY3JvbGwpPT5yZW5kZXIoT2JqZWN0LmFzc2lnbih7fSwgaW5mbywge1xuICAgICAgICAgICAgICAgIEFwcCxcbiAgICAgICAgICAgICAgICBzY3JvbGxcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgbG9jYWxlOiBpbml0aWFsRGF0YS5sb2NhbGUsXG4gICAgICAgIGxvY2FsZXM6IGluaXRpYWxEYXRhLmxvY2FsZXMsXG4gICAgICAgIGRlZmF1bHRMb2NhbGUsXG4gICAgICAgIGRvbWFpbkxvY2FsZXM6IGluaXRpYWxEYXRhLmRvbWFpbkxvY2FsZXMsXG4gICAgICAgIGlzUHJldmlldzogaW5pdGlhbERhdGEuaXNQcmV2aWV3XG4gICAgfSk7XG4gICAgaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlID0gYXdhaXQgcm91dGVyLl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlO1xuICAgIGNvbnN0IHJlbmRlckN0eCA9IHtcbiAgICAgICAgQXBwOiBDYWNoZWRBcHAsXG4gICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgIENvbXBvbmVudDogQ2FjaGVkQ29tcG9uZW50LFxuICAgICAgICBwcm9wczogaW5pdGlhbERhdGEucHJvcHMsXG4gICAgICAgIGVycjogaW5pdGlhbEVyclxuICAgIH07XG4gICAgaWYgKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuYmVmb3JlUmVuZGVyKSB7XG4gICAgICAgIGF3YWl0IG9wdHMuYmVmb3JlUmVuZGVyKCk7XG4gICAgfVxuICAgIHJlbmRlcihyZW5kZXJDdHgpO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJ2ZXJzaW9uIiwicm91dGVyIiwiZW1pdHRlciIsImluaXRpYWxpemUiLCJoeWRyYXRlIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9yZWFjdCIsIl8iLCJfY2xpZW50IiwiX2hlYWRtYW5hZ2VyY29udGV4dHNoYXJlZHJ1bnRpbWUiLCJfbWl0dCIsIl9yb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZSIsIl9oYW5kbGVzbW9vdGhzY3JvbGwiLCJfaXNkeW5hbWljIiwiX3F1ZXJ5c3RyaW5nIiwiX3J1bnRpbWVjb25maWdleHRlcm5hbCIsIl91dGlscyIsIl9wb3J0YWwiLCJfaGVhZG1hbmFnZXIiLCJfcGFnZWxvYWRlciIsIl9wZXJmb3JtYW5jZXJlbGF5ZXIiLCJfcm91dGVhbm5vdW5jZXIiLCJfcm91dGVyIiwiX2lzZXJyb3IiLCJfaW1hZ2Vjb25maWdjb250ZXh0c2hhcmVkcnVudGltZSIsIl9yZW1vdmViYXNlcGF0aCIsIl9oYXNiYXNlcGF0aCIsIl9hcHByb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZSIsIl9hZGFwdGVycyIsIl9ob29rc2NsaWVudGNvbnRleHRzaGFyZWRydW50aW1lIiwiX29ucmVjb3ZlcmFibGVlcnJvciIsIl90cmFjZXIiLCJfcmVwb3J0dG9zb2NrZXQiLCJkZWZhdWx0IiwibG9vc2VUb0FycmF5IiwiaW5wdXQiLCJzbGljZSIsImNhbGwiLCJpbml0aWFsRGF0YSIsImRlZmF1bHRMb2NhbGUiLCJ1bmRlZmluZWQiLCJhc1BhdGgiLCJwYWdlTG9hZGVyIiwiYXBwRWxlbWVudCIsImhlYWRNYW5hZ2VyIiwiaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlIiwibGFzdEFwcFByb3BzIiwibGFzdFJlbmRlclJlamVjdCIsImRldkNsaWVudCIsIkNhY2hlZEFwcCIsIm9uUGVyZkVudHJ5IiwiQ2FjaGVkQ29tcG9uZW50IiwiQ29udGFpbmVyIiwiQ29tcG9uZW50IiwiY29tcG9uZW50RGlkQ2F0Y2giLCJjb21wb25lbnRFcnIiLCJpbmZvIiwicHJvcHMiLCJmbiIsImNvbXBvbmVudERpZE1vdW50Iiwic2Nyb2xsVG9IYXNoIiwiaXNTc3IiLCJpc0ZhbGxiYWNrIiwibmV4dEV4cG9ydCIsImlzRHluYW1pY1JvdXRlIiwicGF0aG5hbWUiLCJsb2NhdGlvbiIsInNlYXJjaCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfSEFTX1JFV1JJVEVTIiwiX19OX1NTRyIsInJlcGxhY2UiLCJTdHJpbmciLCJhc3NpZ24iLCJ1cmxRdWVyeVRvU2VhcmNoUGFyYW1zIiwicXVlcnkiLCJVUkxTZWFyY2hQYXJhbXMiLCJfaCIsInNoYWxsb3ciLCJjYXRjaCIsImVyciIsImNhbmNlbGxlZCIsImNvbXBvbmVudERpZFVwZGF0ZSIsImhhc2giLCJzdWJzdHJpbmciLCJlbCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJzZXRUaW1lb3V0Iiwic2Nyb2xsSW50b1ZpZXciLCJyZW5kZXIiLCJjaGlsZHJlbiIsIlJlYWN0RGV2T3ZlcmxheSIsImNyZWF0ZUVsZW1lbnQiLCJvcHRzIiwib25TcGFuRW5kIiwiSlNPTiIsInBhcnNlIiwidGV4dENvbnRlbnQiLCJ3aW5kb3ciLCJfX05FWFRfREFUQV9fIiwicHJlZml4IiwiYXNzZXRQcmVmaXgiLCJzZWxmIiwiX19uZXh0X3NldF9wdWJsaWNfcGF0aF9fIiwic2V0Q29uZmlnIiwic2VydmVyUnVudGltZUNvbmZpZyIsInB1YmxpY1J1bnRpbWVDb25maWciLCJydW50aW1lQ29uZmlnIiwiZ2V0VVJMIiwiaGFzQmFzZVBhdGgiLCJyZW1vdmVCYXNlUGF0aCIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJub3JtYWxpemVMb2NhbGVQYXRoIiwiZGV0ZWN0RG9tYWluTG9jYWxlIiwicGFyc2VSZWxhdGl2ZVVybCIsImZvcm1hdFVybCIsImxvY2FsZXMiLCJwYXJzZWRBcyIsImxvY2FsZVBhdGhSZXN1bHQiLCJkZXRlY3RlZExvY2FsZSIsImxvY2FsZSIsImRldGVjdGVkRG9tYWluIiwiX19ORVhUX0kxOE5fRE9NQUlOUyIsImhvc3RuYW1lIiwic2NyaXB0TG9hZGVyIiwiaW5pdFNjcmlwdExvYWRlciIsImJ1aWxkSWQiLCJyZWdpc3RlciIsInBhcmFtIiwiciIsImYiLCJyb3V0ZUxvYWRlciIsIm9uRW50cnlwb2ludCIsIl9fTkVYVF9QIiwibWFwIiwicCIsInB1c2giLCJnZXRJc1NzciIsInJlbmRlckFwcCIsIkFwcCIsImFwcFByb3BzIiwiQXBwQ29udGFpbmVyIiwiYWRhcHRlZEZvckFwcFJvdXRlciIsInVzZU1lbW8iLCJhZGFwdEZvckFwcFJvdXRlckluc3RhbmNlIiwiX3NlbGZfX19ORVhUX0RBVEFfX19hdXRvRXhwb3J0IiwiZXJyb3IiLCJyZW5kZXJFcnJvciIsImNvbnNvbGUiLCJBcHBSb3V0ZXJDb250ZXh0IiwiUHJvdmlkZXIiLCJTZWFyY2hQYXJhbXNDb250ZXh0IiwiYWRhcHRGb3JTZWFyY2hQYXJhbXMiLCJQYXRobmFtZUNvbnRleHRQcm92aWRlckFkYXB0ZXIiLCJpc0F1dG9FeHBvcnQiLCJhdXRvRXhwb3J0IiwiUGF0aFBhcmFtc0NvbnRleHQiLCJhZGFwdEZvclBhdGhQYXJhbXMiLCJSb3V0ZXJDb250ZXh0IiwibWFrZVB1YmxpY1JvdXRlckluc3RhbmNlIiwiSGVhZE1hbmFnZXJDb250ZXh0IiwiSW1hZ2VDb25maWdDb250ZXh0IiwiX19ORVhUX0lNQUdFX09QVFMiLCJ3cmFwQXBwIiwid3JhcHBlZEFwcFByb3BzIiwicmVuZGVyRXJyb3JQcm9wcyIsIm9uVW5yZWNvdmVyYWJsZUVycm9yIiwiZG9SZW5kZXIiLCJzdHlsZVNoZWV0cyIsImxvYWRQYWdlIiwidGhlbiIsInBhZ2UiLCJFcnJvckNvbXBvbmVudCIsImVycm9yTW9kdWxlIiwiYXBwTW9kdWxlIiwibSIsIl9yZW5kZXJFcnJvclByb3BzX3Byb3BzIiwiQXBwVHJlZSIsImFwcEN0eCIsImN0eCIsIlByb21pc2UiLCJyZXNvbHZlIiwibG9hZEdldEluaXRpYWxQcm9wcyIsImluaXRQcm9wcyIsIkhlYWQiLCJjYWxsYmFjayIsInVzZUxheW91dEVmZmVjdCIsInBlcmZvcm1hbmNlTWFya3MiLCJuYXZpZ2F0aW9uU3RhcnQiLCJiZWZvcmVSZW5kZXIiLCJhZnRlclJlbmRlciIsImFmdGVySHlkcmF0ZSIsInJvdXRlQ2hhbmdlIiwicGVyZm9ybWFuY2VNZWFzdXJlcyIsImh5ZHJhdGlvbiIsImJlZm9yZUh5ZHJhdGlvbiIsInJvdXRlQ2hhbmdlVG9SZW5kZXIiLCJyZWFjdFJvb3QiLCJzaG91bGRIeWRyYXRlIiwiY2xlYXJNYXJrcyIsImZvckVhY2giLCJtYXJrIiwicGVyZm9ybWFuY2UiLCJtYXJrSHlkcmF0ZUNvbXBsZXRlIiwiU1QiLCJoYXNCZWZvcmVSZW5kZXJNYXJrIiwiZ2V0RW50cmllc0J5TmFtZSIsImxlbmd0aCIsImJlZm9yZUh5ZHJhdGlvbk1lYXN1cmUiLCJtZWFzdXJlIiwiaHlkcmF0aW9uTWVhc3VyZSIsInN0YXJ0U3BhbiIsInN0YXJ0VGltZSIsInRpbWVPcmlnaW4iLCJhdHRyaWJ1dGVzIiwiZW5kIiwiZHVyYXRpb24iLCJtYXJrUmVuZGVyQ29tcGxldGUiLCJuYXZTdGFydEVudHJpZXMiLCJjbGVhck1lYXN1cmVzIiwicmVuZGVyUmVhY3RFbGVtZW50IiwiZG9tRWwiLCJyZWFjdEVsIiwiaHlkcmF0ZVJvb3QiLCJvblJlY292ZXJhYmxlRXJyb3IiLCJzdGFydFRyYW5zaXRpb24iLCJSb290IiwiY2FsbGJhY2tzIiwidXNlRWZmZWN0IiwiX19ORVhUX1RFU1RfTU9ERSIsIl9fTkVYVF9IWURSQVRFRCIsIl9fTkVYVF9IWURSQVRFRF9DQiIsImNhbmNlbGVkIiwicmVzb2x2ZVByb21pc2UiLCJyZW5kZXJQcm9taXNlIiwicmVqZWN0IiwiRXJyb3IiLCJvblN0YXJ0IiwiY3VycmVudFN0eWxlVGFncyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJjdXJyZW50SHJlZnMiLCJTZXQiLCJ0YWciLCJnZXRBdHRyaWJ1dGUiLCJub3NjcmlwdCIsInF1ZXJ5U2VsZWN0b3IiLCJub25jZSIsImhyZWYiLCJ0ZXh0IiwiaGFzIiwic3R5bGVUYWciLCJzZXRBdHRyaWJ1dGUiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJjcmVhdGVUZXh0Tm9kZSIsIm9uSGVhZENvbW1pdCIsImRlc2lyZWRIcmVmcyIsInMiLCJpZHgiLCJyZW1vdmVBdHRyaWJ1dGUiLCJyZWZlcmVuY2VOb2RlIiwidGFyZ2V0VGFnIiwicGFyZW50Tm9kZSIsImluc2VydEJlZm9yZSIsIm5leHRTaWJsaW5nIiwicmVtb3ZlQ2hpbGQiLCJzY3JvbGwiLCJ4IiwieSIsImhhbmRsZVNtb290aFNjcm9sbCIsInNjcm9sbFRvIiwib25Sb290Q29tbWl0IiwiZWxlbSIsIkZyYWdtZW50IiwiUG9ydGFsIiwidHlwZSIsIlJvdXRlQW5ub3VuY2VyIiwiX19ORVhUX1NUUklDVF9NT0RFIiwiU3RyaWN0TW9kZSIsInJlbmRlcmluZ1Byb3BzIiwicmVuZGVyRXJyIiwiZ2V0UHJvcGVyRXJyb3IiLCJpbml0aWFsRXJyIiwiYXBwRW50cnlwb2ludCIsIndoZW5FbnRyeXBvaW50IiwiY29tcG9uZW50IiwiYXBwIiwibW9kIiwicmVwb3J0V2ViVml0YWxzIiwiaWQiLCJlbnRyeVR5cGUiLCJlbnRyaWVzIiwiYXR0cmlidXRpb24iLCJ1bmlxdWVJRCIsIkRhdGUiLCJub3ciLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJwZXJmU3RhcnRFbnRyeSIsIndlYlZpdGFscyIsImxhYmVsIiwicGFnZUVudHJ5cG9pbnQiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJnZXRTZXJ2ZXJFcnJvciIsIm1lc3NhZ2UiLCJlIiwic3RhY2siLCJzb3VyY2UiLCJfX05FWFRfUFJFTE9BRFJFQURZIiwiZHluYW1pY0lkcyIsImNyZWF0ZVJvdXRlciIsImluaXRpYWxQcm9wcyIsIkJvb2xlYW4iLCJzdWJzY3JpcHRpb24iLCJkb21haW5Mb2NhbGVzIiwiaXNQcmV2aWV3IiwiX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2UiLCJyZW5kZXJDdHgiLCJpbml0aWFsIiwiX19lc01vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/next/dist/client/index.js\n"));

/***/ })

});